From dd68c10989c37428d4a0b38982e6229866e929c9 Mon Sep 17 00:00:00 2001
From: wwright <wwright@methode.com>
Date: Wed, 24 Jun 2015 13:39:59 -0500
Subject: [PATCH] u-boot 2013.01.01 cti dcim

---
 arch/arm/cpu/armv7/am33xx/board.c                  |   8 +
 arch/arm/cpu/armv7/am33xx/clock.c                  |  90 ++-
 arch/arm/cpu/armv7/am33xx/clock_am33xx.c           | 161 ++++++
 arch/arm/cpu/armv7/am33xx/clock_new.c              | 177 ++++++
 arch/arm/cpu/armv7/am33xx/sys_info.c               |  67 +++
 arch/arm/cpu/armv7/omap-common/boot-common.c       |   3 +-
 arch/arm/include/asm/arch-am33xx/clocks_am33xx.h   |   5 +
 .../include/asm/arch-am33xx/clocks_am33xx_copy.h   |  69 +++
 .../include/asm/arch-am33xx/clocks_am33xx_new.h    |  38 ++
 arch/arm/include/asm/arch-am33xx/cpu.h             |   7 +
 arch/arm/include/asm/arch-am33xx/sys_proto.h       |   3 +
 arch/arm/include/asm/arch-omap3/mux.h              | 632 ++++++---------------
 arch/arm/include/asm/omap_common.h                 |  16 +-
 board/cti/dcim/Makefile                            |  46 ++
 board/cti/dcim/board.c                             | 627 ++++++++++++++++++++
 board/cti/dcim/board.h                             |  54 ++
 board/cti/dcim/mux.c                               | 601 ++++++++++++++++++++
 board/cti/dcim/pmic.h                              |  77 +++
 board/cti/dcim/tps65217.h                          |  92 +++
 board/cti/dcim/tps65910.h                          |  76 +++
 board/cti/dcim/u-boot.lds                          | 101 ++++
 board/hetronic/htouch/Makefile                     |  46 ++
 board/hetronic/htouch/board.c                      | 627 ++++++++++++++++++++
 board/hetronic/htouch/board.h                      |  54 ++
 board/hetronic/htouch/mux.c                        | 601 ++++++++++++++++++++
 board/hetronic/htouch/pmic.h                       |  77 +++
 board/hetronic/htouch/tps65217.h                   |  92 +++
 board/hetronic/htouch/tps65910.h                   |  76 +++
 board/hetronic/htouch/u-boot.lds                   | 101 ++++
 boards.cfg                                         |   2 +
 common/spl/spl_nand.c                              |   6 +
 common/spl/spl_net.c                               |   2 +
 dcim.boards.cfg                                    |   2 +
 drivers/i2c/omap24xx_i2c.c                         |   4 +
 drivers/mmc/spl_mmc.c                              |  90 ++-
 drivers/net/phy/marvell.c                          |  64 ++-
 drivers/usb/musb-new/musb_core.c                   |   2 +-
 include/configs/dcim.h                             | 594 +++++++++++++++++++
 include/configs/htouch.h                           | 594 +++++++++++++++++++
 include/cpsw.h                                     |   2 +
 include/power/tps65217.h                           |  83 +++
 include/power/tps65910.h                           |  77 +++
 42 files changed, 5645 insertions(+), 501 deletions(-)
 mode change 100644 => 100755 arch/arm/cpu/armv7/am33xx/clock.c
 create mode 100644 arch/arm/cpu/armv7/am33xx/clock_am33xx.c
 create mode 100644 arch/arm/cpu/armv7/am33xx/clock_new.c
 create mode 100644 arch/arm/include/asm/arch-am33xx/clocks_am33xx_copy.h
 create mode 100644 arch/arm/include/asm/arch-am33xx/clocks_am33xx_new.h
 create mode 100644 board/cti/dcim/Makefile
 create mode 100644 board/cti/dcim/board.c
 create mode 100644 board/cti/dcim/board.h
 create mode 100644 board/cti/dcim/mux.c
 create mode 100644 board/cti/dcim/pmic.h
 create mode 100644 board/cti/dcim/tps65217.h
 create mode 100644 board/cti/dcim/tps65910.h
 create mode 100644 board/cti/dcim/u-boot.lds
 create mode 100644 board/hetronic/htouch/Makefile
 create mode 100644 board/hetronic/htouch/board.c
 create mode 100644 board/hetronic/htouch/board.h
 create mode 100644 board/hetronic/htouch/mux.c
 create mode 100644 board/hetronic/htouch/pmic.h
 create mode 100644 board/hetronic/htouch/tps65217.h
 create mode 100644 board/hetronic/htouch/tps65910.h
 create mode 100644 board/hetronic/htouch/u-boot.lds
 create mode 100644 dcim.boards.cfg
 create mode 100644 include/configs/dcim.h
 create mode 100644 include/configs/htouch.h
 create mode 100644 include/power/tps65217.h
 create mode 100644 include/power/tps65910.h

diff --git a/arch/arm/cpu/armv7/am33xx/board.c b/arch/arm/cpu/armv7/am33xx/board.c
index 5cbf96e..ddab5d4 100644
--- a/arch/arm/cpu/armv7/am33xx/board.c
+++ b/arch/arm/cpu/armv7/am33xx/board.c
@@ -169,3 +169,11 @@ void s_init(void)
 	s1_init();
 }
 #endif
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+void enable_caches(void)
+{
+	/* Enable D-Cache. I-Cache is already enabled in start.S */
+	dcache_enable();
+}
+#endif
diff --git a/arch/arm/cpu/armv7/am33xx/clock.c b/arch/arm/cpu/armv7/am33xx/clock.c
old mode 100644
new mode 100755
index f9f2036..b6d874c
--- a/arch/arm/cpu/armv7/am33xx/clock.c
+++ b/arch/arm/cpu/armv7/am33xx/clock.c
@@ -249,10 +249,11 @@ void core_pll_config(int opp)
 	div_m4 = readl(&cmwkup->divm4dpllcore);
 	div_m5 = readl(&cmwkup->divm5dpllcore);
 	div_m6 = readl(&cmwkup->divm6dpllcore);
-
+	puts("Inside core_pll_config \n");
 	/* Set the PLL to bypass Mode */
 	writel(PLL_BYPASS_MODE, &cmwkup->clkmoddpllcore);
 
+	opp = OPP_100;
 	while (readl(&cmwkup->idlestdpllcore) != ST_MN_BYPASS)
 			;
 	if (opp == OPP_50) {
@@ -279,6 +280,7 @@ void core_pll_config(int opp)
 		while (readl(&cmwkup->idlestdpllcore) != ST_DPLL_CLK)
 		;
 	} else {
+		printf("#### setting opp 100  #####\n");
 		clksel = clksel & (~CLK_SEL_MASK);
 		clksel = clksel | ((COREPLL_M << CLK_SEL_SHIFT) | COREPLL_N);
 		writel(clksel, &cmwkup->clkseldpllcore);
@@ -397,3 +399,89 @@ void pll_init()
 	/* Enable the required peripherals */
 	enable_per_clocks();
 }
+
+#include <asm/omap_common.h>
+#define CM_CLKSEL_DPLL_M_MASK	(0x7FF << 8)
+#define CM_CLKSEL_DPLL_M_SHIFT	8
+#define CM_CLKSEL_DPLL_N_MASK	0x7F
+#define CM_CLKSEL_DPLL_N_SHIFT	0
+#define CM_CLKMODE_DPLL_DPLL_EN_MASK	7
+#define DPLL_EN_MN_BYPASS	4
+#define CM_CLKMODE_DPLL_EN_SHIFT	0
+#define DPLL_EN_LOCK	7
+#define ST_DPLL_CLK_MASK	1
+#define LDELAY	12000000
+
+static inline void do_bypass_dpll(const struct dpll_regs *dpll_regs)
+{
+	clrsetbits_le32(dpll_regs->cm_clkmode_dpll,
+	CM_CLKMODE_DPLL_DPLL_EN_MASK,
+	DPLL_EN_MN_BYPASS << CM_CLKMODE_DPLL_EN_SHIFT);
+}
+static inline void wait_for_bypass(const struct dpll_regs *dpll_regs)
+{
+if (!wait_on_value(ST_DPLL_CLK_MASK, 0,
+(void *)dpll_regs->cm_idlest_dpll, LDELAY)) {
+printf("Bypassing DPLL failed 0x%x\n",
+dpll_regs->cm_clkmode_dpll);
+}
+}
+static void bypass_dpll(const struct dpll_regs *dpll_regs)
+{
+	do_bypass_dpll(dpll_regs);
+	wait_for_bypass(dpll_regs);
+}
+
+static void setup_post_dividers(const struct dpll_regs *dpll_regs,
+const struct dpll_params *params)
+{
+	// Setup post-dividers 
+	if (params->m2 >= 0)
+	writel(params->m2, dpll_regs->cm_div_m2_dpll);
+	if (params->m3 >= 0)
+	writel(params->m3, dpll_regs->cm_div_m3_dpll);
+	if (params->m4 >= 0)
+	writel(params->m4, dpll_regs->cm_div_m4_dpll);
+	if (params->m5 >= 0)
+	writel(params->m5, dpll_regs->cm_div_m5_dpll);
+	if (params->m6 >= 0)
+	writel(params->m6, dpll_regs->cm_div_m6_dpll);
+}
+
+static inline void do_lock_dpll(const struct dpll_regs *dpll_regs)
+{
+	clrsetbits_le32(dpll_regs->cm_clkmode_dpll,
+	CM_CLKMODE_DPLL_DPLL_EN_MASK,
+	DPLL_EN_LOCK << CM_CLKMODE_DPLL_EN_SHIFT);
+}
+
+
+static inline void wait_for_lock(const struct dpll_regs *dpll_regs)
+{
+	if (!wait_on_value(ST_DPLL_CLK_MASK, ST_DPLL_CLK_MASK,
+	(void *)dpll_regs->cm_idlest_dpll, LDELAY)) {
+	printf("DPLL locking failed for 0x%x\n",
+	dpll_regs->cm_clkmode_dpll);
+	hang();
+	}
+}
+
+void do_setup_dpll(const struct dpll_regs *dpll_regs,
+const struct dpll_params *params)
+{
+	u32 temp;
+	if (!params)
+	return;
+	temp = readl(dpll_regs->cm_clksel_dpll);
+	bypass_dpll(dpll_regs);
+	/* Set M & N */
+	temp &= ~CM_CLKSEL_DPLL_M_MASK;
+	temp |= (params->m << CM_CLKSEL_DPLL_M_SHIFT) & CM_CLKSEL_DPLL_M_MASK;
+	temp &= ~CM_CLKSEL_DPLL_N_MASK;
+	temp |= (params->n << CM_CLKSEL_DPLL_N_SHIFT) & CM_CLKSEL_DPLL_N_MASK;
+	writel(temp, dpll_regs->cm_clksel_dpll);
+	setup_post_dividers(dpll_regs, params);
+	/* Wait till the DPLL locks */
+	do_lock_dpll(dpll_regs);
+	wait_for_lock(dpll_regs);
+}
diff --git a/arch/arm/cpu/armv7/am33xx/clock_am33xx.c b/arch/arm/cpu/armv7/am33xx/clock_am33xx.c
new file mode 100644
index 0000000..92142c8
--- /dev/null
+++ b/arch/arm/cpu/armv7/am33xx/clock_am33xx.c
@@ -0,0 +1,161 @@
+/*
+ * clock_am33xx.c
+ *
+ * clocks for AM33XX based boards
+ *
+ * Copyright (C) 2013, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#define OSC	(V_OSCK/1000000)
+
+struct cm_perpll *const cmper = (struct cm_perpll *)CM_PER;
+struct cm_wkuppll *const cmwkup = (struct cm_wkuppll *)CM_WKUP;
+struct cm_dpll *const cmdpll = (struct cm_dpll *)CM_DPLL;
+struct cm_rtc *const cmrtc = (struct cm_rtc *)CM_RTC;
+
+const struct dpll_regs dpll_mpu_regs = {
+	.cm_clkmode_dpll	= CM_WKUP + 0x88,
+	.cm_idlest_dpll		= CM_WKUP + 0x20,
+	.cm_clksel_dpll		= CM_WKUP + 0x2C,
+	.cm_div_m2_dpll		= CM_WKUP + 0xA8,
+};
+
+const struct dpll_regs dpll_core_regs = {
+	.cm_clkmode_dpll	= CM_WKUP + 0x90,
+	.cm_idlest_dpll		= CM_WKUP + 0x5C,
+	.cm_clksel_dpll		= CM_WKUP + 0x68,
+	.cm_div_m4_dpll		= CM_WKUP + 0x80,
+	.cm_div_m5_dpll		= CM_WKUP + 0x84,
+	.cm_div_m6_dpll		= CM_WKUP + 0xD8,
+};
+
+const struct dpll_regs dpll_per_regs = {
+	.cm_clkmode_dpll	= CM_WKUP + 0x8C,
+	.cm_idlest_dpll		= CM_WKUP + 0x70,
+	.cm_clksel_dpll		= CM_WKUP + 0x9C,
+	.cm_div_m2_dpll		= CM_WKUP + 0xAC,
+};
+
+const struct dpll_regs dpll_ddr_regs = {
+	.cm_clkmode_dpll	= CM_WKUP + 0x94,
+	.cm_idlest_dpll		= CM_WKUP + 0x34,
+	.cm_clksel_dpll		= CM_WKUP + 0x40,
+	.cm_div_m2_dpll		= CM_WKUP + 0xA0,
+};
+
+struct dpll_params dpll_mpu_opp100 = {
+		CONFIG_SYS_MPUCLK, OSC-1, 1, -1, -1, -1, -1};
+const struct dpll_params dpll_core_opp100 = {
+		1000, OSC-1, -1, -1, 10, 8, 4};
+const struct dpll_params dpll_mpu = {
+		MPUPLL_M_300, OSC-1, 1, -1, -1, -1, -1};
+const struct dpll_params dpll_core = {
+		50, OSC-1, -1, -1, 1, 1, 1};
+const struct dpll_params dpll_per = {
+		960, OSC-1, 5, -1, -1, -1, -1};
+
+const struct dpll_params *get_dpll_mpu_params(void)
+{
+	return &dpll_mpu;
+}
+
+const struct dpll_params *get_dpll_core_params(void)
+{
+	return &dpll_core;
+}
+
+const struct dpll_params *get_dpll_per_params(void)
+{
+	return &dpll_per;
+}
+
+void setup_clocks_for_console(void)
+{
+	clrsetbits_le32(&cmwkup->wkclkstctrl, CD_CLKCTRL_CLKTRCTRL_MASK,
+			CD_CLKCTRL_CLKTRCTRL_SW_WKUP <<
+			CD_CLKCTRL_CLKTRCTRL_SHIFT);
+
+	clrsetbits_le32(&cmper->l4hsclkstctrl, CD_CLKCTRL_CLKTRCTRL_MASK,
+			CD_CLKCTRL_CLKTRCTRL_SW_WKUP <<
+			CD_CLKCTRL_CLKTRCTRL_SHIFT);
+
+	clrsetbits_le32(&cmwkup->wkup_uart0ctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	clrsetbits_le32(&cmper->uart1clkctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	clrsetbits_le32(&cmper->uart2clkctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	clrsetbits_le32(&cmper->uart3clkctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	clrsetbits_le32(&cmper->uart4clkctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	clrsetbits_le32(&cmper->uart5clkctrl,
+			MODULE_CLKCTRL_MODULEMODE_MASK,
+			MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN <<
+			MODULE_CLKCTRL_MODULEMODE_SHIFT);
+}
+
+void enable_basic_clocks(void)
+{
+	u32 *const clk_domains[] = {
+		&cmper->l3clkstctrl,
+		&cmper->l4fwclkstctrl,
+		&cmper->l3sclkstctrl,
+		&cmper->l4lsclkstctrl,
+		&cmwkup->wkclkstctrl,
+		&cmper->emiffwclkctrl,
+		&cmrtc->clkstctrl,
+		0
+	};
+
+	u32 *const clk_modules_explicit_en[] = {
+		&cmper->l3clkctrl,
+		&cmper->l4lsclkctrl,
+		&cmper->l4fwclkctrl,
+		&cmwkup->wkl4wkclkctrl,
+		&cmper->l3instrclkctrl,
+		&cmper->l4hsclkctrl,
+		&cmwkup->wkgpio0clkctrl,
+		&cmwkup->wkctrlclkctrl,
+		&cmper->timer2clkctrl,
+		&cmper->gpmcclkctrl,
+		&cmper->elmclkctrl,
+		&cmper->mmc0clkctrl,
+		&cmper->mmc1clkctrl,
+		&cmwkup->wkup_i2c0ctrl,
+		&cmper->gpio1clkctrl,
+		&cmper->gpio2clkctrl,
+		&cmper->gpio3clkctrl,
+		&cmper->i2c1clkctrl,
+		&cmper->cpgmac0clkctrl,
+		&cmper->spi0clkctrl,
+		&cmrtc->rtcclkctrl,
+		&cmper->usb0clkctrl,
+		&cmper->emiffwclkctrl,
+		&cmper->emifclkctrl,
+		0
+	};
+
+	do_enable_clocks(clk_domains, clk_modules_explicit_en, 1);
+
+	/* Select the Master osc 24 MHZ as Timer2 clock source */
+	writel(0x1, &cmdpll->clktimer2clk);
+}
diff --git a/arch/arm/cpu/armv7/am33xx/clock_new.c b/arch/arm/cpu/armv7/am33xx/clock_new.c
new file mode 100644
index 0000000..0672798
--- /dev/null
+++ b/arch/arm/cpu/armv7/am33xx/clock_new.c
@@ -0,0 +1,177 @@
+/*
+ * clock.c
+ *
+ * Clock initialization for AM33XX boards.
+ * Derived from OMAP4 boards
+ *
+ * Copyright (C) 2013, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+
+static void setup_post_dividers(const struct dpll_regs *dpll_regs,
+			 const struct dpll_params *params)
+{
+	/* Setup post-dividers */
+	if (params->m2 >= 0)
+		writel(params->m2, dpll_regs->cm_div_m2_dpll);
+	if (params->m3 >= 0)
+		writel(params->m3, dpll_regs->cm_div_m3_dpll);
+	if (params->m4 >= 0)
+		writel(params->m4, dpll_regs->cm_div_m4_dpll);
+	if (params->m5 >= 0)
+		writel(params->m5, dpll_regs->cm_div_m5_dpll);
+	if (params->m6 >= 0)
+		writel(params->m6, dpll_regs->cm_div_m6_dpll);
+}
+
+static inline void do_lock_dpll(const struct dpll_regs *dpll_regs)
+{
+	clrsetbits_le32(dpll_regs->cm_clkmode_dpll,
+			CM_CLKMODE_DPLL_DPLL_EN_MASK,
+			DPLL_EN_LOCK << CM_CLKMODE_DPLL_EN_SHIFT);
+}
+
+static inline void wait_for_lock(const struct dpll_regs *dpll_regs)
+{
+	if (!wait_on_value(ST_DPLL_CLK_MASK, ST_DPLL_CLK_MASK,
+			   (void *)dpll_regs->cm_idlest_dpll, LDELAY)) {
+		printf("DPLL locking failed for 0x%x\n",
+		       dpll_regs->cm_clkmode_dpll);
+		hang();
+	}
+}
+
+static inline void do_bypass_dpll(const struct dpll_regs *dpll_regs)
+{
+	clrsetbits_le32(dpll_regs->cm_clkmode_dpll,
+			CM_CLKMODE_DPLL_DPLL_EN_MASK,
+			DPLL_EN_MN_BYPASS << CM_CLKMODE_DPLL_EN_SHIFT);
+}
+
+static inline void wait_for_bypass(const struct dpll_regs *dpll_regs)
+{
+	if (!wait_on_value(ST_DPLL_CLK_MASK, 0,
+			   (void *)dpll_regs->cm_idlest_dpll, LDELAY)) {
+		printf("Bypassing DPLL failed 0x%x\n",
+		       dpll_regs->cm_clkmode_dpll);
+	}
+}
+
+static void bypass_dpll(const struct dpll_regs *dpll_regs)
+{
+	do_bypass_dpll(dpll_regs);
+	wait_for_bypass(dpll_regs);
+}
+
+void do_setup_dpll(const struct dpll_regs *dpll_regs,
+		   const struct dpll_params *params)
+{
+	u32 temp;
+
+	if (!params)
+		return;
+
+	temp = readl(dpll_regs->cm_clksel_dpll);
+
+	bypass_dpll(dpll_regs);
+
+	/* Set M & N */
+	temp &= ~CM_CLKSEL_DPLL_M_MASK;
+	temp |= (params->m << CM_CLKSEL_DPLL_M_SHIFT) & CM_CLKSEL_DPLL_M_MASK;
+
+	temp &= ~CM_CLKSEL_DPLL_N_MASK;
+	temp |= (params->n << CM_CLKSEL_DPLL_N_SHIFT) & CM_CLKSEL_DPLL_N_MASK;
+
+	writel(temp, dpll_regs->cm_clksel_dpll);
+
+	setup_post_dividers(dpll_regs, params);
+
+	/* Wait till the DPLL locks */
+	do_lock_dpll(dpll_regs);
+	wait_for_lock(dpll_regs);
+}
+
+static void setup_dplls(void)
+{
+	const struct dpll_params *params;
+
+	params = get_dpll_core_params();
+	do_setup_dpll(&dpll_core_regs, params);
+
+	params = get_dpll_mpu_params();
+	do_setup_dpll(&dpll_mpu_regs, params);
+
+	params = get_dpll_per_params();
+	do_setup_dpll(&dpll_per_regs, params);
+	writel(0x300, &cmwkup->clkdcoldodpllper);
+
+	params = get_dpll_ddr_params();
+	do_setup_dpll(&dpll_ddr_regs, params);
+}
+
+static inline void wait_for_clk_enable(u32 *clkctrl_addr)
+{
+	u32 clkctrl, idlest = MODULE_CLKCTRL_IDLEST_DISABLED;
+	u32 bound = LDELAY;
+
+	while ((idlest == MODULE_CLKCTRL_IDLEST_DISABLED) ||
+		(idlest == MODULE_CLKCTRL_IDLEST_TRANSITIONING)) {
+		clkctrl = readl(clkctrl_addr);
+		idlest = (clkctrl & MODULE_CLKCTRL_IDLEST_MASK) >>
+			 MODULE_CLKCTRL_IDLEST_SHIFT;
+		if (--bound == 0) {
+			printf("Clock enable failed for 0x%p idlest 0x%x\n",
+			       clkctrl_addr, clkctrl);
+			return;
+		}
+	}
+}
+
+static inline void enable_clock_module(u32 *const clkctrl_addr, u32 enable_mode,
+				       u32 wait_for_enable)
+{
+	clrsetbits_le32(clkctrl_addr, MODULE_CLKCTRL_MODULEMODE_MASK,
+			enable_mode << MODULE_CLKCTRL_MODULEMODE_SHIFT);
+	debug("Enable clock module - %p\n", clkctrl_addr);
+	if (wait_for_enable)
+		wait_for_clk_enable(clkctrl_addr);
+}
+
+static inline void enable_clock_domain(u32 *const clkctrl_reg, u32 enable_mode)
+{
+	clrsetbits_le32(clkctrl_reg, CD_CLKCTRL_CLKTRCTRL_MASK,
+			enable_mode << CD_CLKCTRL_CLKTRCTRL_SHIFT);
+	debug("Enable clock domain - %p\n", clkctrl_reg);
+}
+
+void do_enable_clocks(u32 *const *clk_domains,
+		      u32 *const *clk_modules_explicit_en, u8 wait_for_enable)
+{
+	u32 i, max = 100;
+
+	/* Put the clock domains in SW_WKUP mode */
+	for (i = 0; (i < max) && clk_domains[i]; i++) {
+		enable_clock_domain(clk_domains[i],
+				    CD_CLKCTRL_CLKTRCTRL_SW_WKUP);
+	}
+
+	/* Clock modules that need to be put in SW_EXPLICIT_EN mode */
+	for (i = 0; (i < max) && clk_modules_explicit_en[i]; i++) {
+		enable_clock_module(clk_modules_explicit_en[i],
+				    MODULE_CLKCTRL_MODULEMODE_SW_EXPLICIT_EN,
+				    wait_for_enable);
+	};
+}
+
+void prcm_init()
+{
+	enable_basic_clocks();
+	setup_dplls();
+}
diff --git a/arch/arm/cpu/armv7/am33xx/sys_info.c b/arch/arm/cpu/armv7/am33xx/sys_info.c
index 507b618..66c4c36 100644
--- a/arch/arm/cpu/armv7/am33xx/sys_info.c
+++ b/arch/arm/cpu/armv7/am33xx/sys_info.c
@@ -25,6 +25,7 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/clock.h>
+#include <power/tps65910.h>
 
 struct ctrl_stat *cstat = (struct ctrl_stat *)CTRL_BASE;
 
@@ -128,3 +129,69 @@ int print_cpuinfo(void)
 	return 0;
 }
 #endif	/* CONFIG_DISPLAY_CPUINFO */
+//#ifdef CONFIG_AM33XX
+/* MPU max frequencies */
+#define AM335X_ZCZ_800 0x1E2F
+#define AM335X_ZCZ_1000 0x1C2F
+#define AM335X_ZCZ_720			0x1F2F
+#define AM335X_ZCZ_800			0x1E2F
+#define AM335X_ZCZ_1000			0x1C2F
+#define AM335X_ZCE_300			0x1FDF
+#define AM335X_ZCE_600			0x1F9F
+#define AM335X_ZCZ_300			0x1FEF
+#define AM335X_ZCZ_600			0x1FAF
+int am335x_get_efuse_mpu_max_freq(struct ctrl_dev *cdev)
+{
+	int sil_rev;
+
+	sil_rev = readl(cdev->deviceid) >> 28;
+
+	if (sil_rev == 1)
+		/* PG 2.0, efuse may not be set. */
+		return MPUPLL_M_800;
+	else if (sil_rev >= 2) {
+		/* Check what the efuse says our max speed is. */
+		int efuse_arm_mpu_max_freq;
+		efuse_arm_mpu_max_freq = readl(cdev->efuse_sma);
+		switch ((efuse_arm_mpu_max_freq & DEVICE_ID_MASK)) {
+		case AM335X_ZCZ_1000:
+			return MPUPLL_M_1000;
+		case AM335X_ZCZ_800:
+			return MPUPLL_M_800;
+		case AM335X_ZCZ_720:
+				printf("****MPUPLL_M_720*****\n");
+			return MPUPLL_M_720;
+		case AM335X_ZCZ_600:
+		case AM335X_ZCE_600:
+			return MPUPLL_M_600;
+		case AM335X_ZCZ_300:
+		case AM335X_ZCE_300:
+			return MPUPLL_M_300;
+		}
+	}
+
+	/* PG 1.0 or otherwise unknown, use the PG1.0 max */
+	return MPUPLL_M_720;
+}
+
+int am335x_get_tps65910_mpu_vdd(int sil_rev, int frequency)
+{
+	/* For PG2.1 and later, we have one set of values. */
+	if (sil_rev >= 2) {
+		switch (frequency) {
+		case MPUPLL_M_1000:
+			return TPS65910_OP_REG_SEL_1_3_2_5;
+		case MPUPLL_M_800:
+			return TPS65910_OP_REG_SEL_1_2_6;
+		case MPUPLL_M_720:
+			return TPS65910_OP_REG_SEL_1_2_0;
+		case MPUPLL_M_600:
+	case MPUPLL_M_300:
+			return TPS65910_OP_REG_SEL_1_1_3;
+		}
+	}
+
+	/* Default to PG1.0/PG2.0 values. */
+	return TPS65910_OP_REG_SEL_1_1_3;
+}
+//#endif
diff --git a/arch/arm/cpu/armv7/omap-common/boot-common.c b/arch/arm/cpu/armv7/omap-common/boot-common.c
index 4f63ba3..abfb286 100644
--- a/arch/arm/cpu/armv7/omap-common/boot-common.c
+++ b/arch/arm/cpu/armv7/omap-common/boot-common.c
@@ -38,7 +38,8 @@ struct omap_boot_parameters boot_params __attribute__ ((section(".data")));
  * We would not typically need to save these parameters in regular
  * U-Boot. This is needed only in SPL at the moment.
  */
-u32 omap_bootmode = MMCSD_MODE_FAT;
+//u32 omap_bootmode = MMCSD_MODE_FAT;
+u32 omap_bootmode = MMCSD_MODE_RAW;
 
 u32 spl_boot_device(void)
 {
diff --git a/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h b/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h
index 580793a..6aed3b8 100644
--- a/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h
+++ b/arch/arm/include/asm/arch-am33xx/clocks_am33xx.h
@@ -33,6 +33,9 @@
 #define MPUPLL_N	(OSC-1)
 #define MPUPLL_M2	1
 
+#define CONFIG_SYS_MPUCLK	MPUPLL_M_550
+#define MPUPLL_M_600	600
+
 /* Core PLL Fdll = 1 GHZ, */
 #define COREPLL_M	1000
 #define COREPLL_M_OPP50 50
@@ -63,5 +66,7 @@
 
 extern void pll_init(void);
 extern void enable_emif_clocks(void);
+extern const struct dpll_params dpll_core_opp100;
+extern struct dpll_params dpll_mpu_opp100;
 
 #endif	/* endif _CLOCKS_AM33XX_H_ */
diff --git a/arch/arm/include/asm/arch-am33xx/clocks_am33xx_copy.h b/arch/arm/include/asm/arch-am33xx/clocks_am33xx_copy.h
new file mode 100644
index 0000000..d2ae55d
--- /dev/null
+++ b/arch/arm/include/asm/arch-am33xx/clocks_am33xx_copy.h
@@ -0,0 +1,69 @@
+/*
+ * clocks_am33xx.h
+ *
+ * AM33xx clock define
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _CLOCKS_AM33XX_H_
+#define _CLOCKS_AM33XX_H_
+
+#define OPP_50	50
+#define OPP_100	100
+
+#define OSC	(V_OSCK/1000000)
+
+/* MAIN PLL Fdll = 550MHz, 720MHz, 800MHz or 1GHz */
+#define MPUPLL_M_1000	1000
+#define MPUPLL_M_800	800
+#define MPUPLL_M_720	720
+#define MPUPLL_M_550	550
+#define MPUPLL_M_300	300
+#define MPUPLL_N	(OSC-1)
+#define MPUPLL_M2	1
+
+/* Core PLL Fdll = 1 GHZ, */
+#define COREPLL_M	1000
+#define COREPLL_M_OPP50 50
+#define COREPLL_N	(OSC-1)
+
+#define COREPLL_M4	10	/* CORE_CLKOUTM4 = 200 MHZ */
+#define COREPLL_M5	8	/* CORE_CLKOUTM5 = 250 MHZ */
+#define COREPLL_M6	4	/* CORE_CLKOUTM6 = 500 MHZ */
+
+#define COREPLL_M4_OPP50	1
+#define COREPLL_M5_OPP50	1
+#define COREPLL_M6_OPP50	1
+
+/*
+ * USB PHY clock is 960 MHZ. Since, this comes directly from Fdll, Fdll
+ * frequency needs to be set to 960 MHZ. Hence,
+ * For clkout = 192 MHZ, Fdll = 960 MHZ, divider values are given below
+ */
+#define PERPLL_M	960
+#define PERPLL_N	(OSC-1)
+#define PERPLL_M2	5
+
+/* DDR Freq is 266 MHZ for now */
+/* Set Fdll = 400 MHZ , Fdll = M * 2 * CLKINP/ N + 1; clkout = Fdll /(2 * M2) */
+#define DDRPLL_M	266
+#define DDRPLL_N	(OSC-1)
+#define DDRPLL_M2	1
+
+extern void pll_init(void);
+extern void enable_emif_clocks(void);
+extern const struct dpll_params dpll_core_opp100;
+extern struct dpll_params dpll_mpu_opp100;
+
+#endif	/* endif _CLOCKS_AM33XX_H_ */
diff --git a/arch/arm/include/asm/arch-am33xx/clocks_am33xx_new.h b/arch/arm/include/asm/arch-am33xx/clocks_am33xx_new.h
new file mode 100644
index 0000000..4c9352a
--- /dev/null
+++ b/arch/arm/include/asm/arch-am33xx/clocks_am33xx_new.h
@@ -0,0 +1,38 @@
+/*
+ * clocks_am33xx.h
+ *
+ * AM33xx clock define
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _CLOCKS_AM33XX_H_
+#define _CLOCKS_AM33XX_H_
+
+/* MAIN PLL Fdll supported frequencies */
+#define MPUPLL_M_1000	1000
+#define MPUPLL_M_800	800
+#define MPUPLL_M_720	720
+#define MPUPLL_M_600	600
+#define MPUPLL_M_550	550
+#define MPUPLL_M_300	300
+
+/* MAIN PLL Fdll = 550 MHz, by default */
+#ifndef CONFIG_SYS_MPUCLK
+#define CONFIG_SYS_MPUCLK	MPUPLL_M_550
+#endif
+
+#define UART_RESET		(0x1 << 1)
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+#define CM_DLL_CTRL_NO_OVERRIDE	0x0
+#define CM_DLL_READYST		0x4
+
+extern void enable_dmm_clocks(void);
+extern const struct dpll_params dpll_core_opp100;
+extern struct dpll_params dpll_mpu_opp100;
+
+#endif	/* endif _CLOCKS_AM33XX_H_ */
diff --git a/arch/arm/include/asm/arch-am33xx/cpu.h b/arch/arm/include/asm/arch-am33xx/cpu.h
index b79124a..69fdb2a 100644
--- a/arch/arm/include/asm/arch-am33xx/cpu.h
+++ b/arch/arm/include/asm/arch-am33xx/cpu.h
@@ -331,6 +331,13 @@ struct ctrl_stat {
 #define OMAP_GPIO_CLEARDATAOUT		0x0190
 #define OMAP_GPIO_SETDATAOUT		0x0194
 
+/* rgmii registers */ 
+//#define RGMII1_IDMODE                   BIT(4)
+//#define RGMII2_IDMODE                   BIT(5)
+
+//#define RGMII_INT_DELAY                 (RGMII1_IDMODE | RGMII2_IDMODE)
+
+
 /* Control Device Register */
 struct ctrl_dev {
 	unsigned int deviceid;		/* offset 0x00 */
diff --git a/arch/arm/include/asm/arch-am33xx/sys_proto.h b/arch/arm/include/asm/arch-am33xx/sys_proto.h
index ef1d395..d7cff2b 100644
--- a/arch/arm/include/asm/arch-am33xx/sys_proto.h
+++ b/arch/arm/include/asm/arch-am33xx/sys_proto.h
@@ -18,6 +18,7 @@
 
 #ifndef _SYS_PROTO_H_
 #define _SYS_PROTO_H_
+#include <asm/arch/cpu.h>
 
 #define BOARD_REV_ID	0x0
 
@@ -38,4 +39,6 @@ void sdelay(unsigned long);
 void gpmc_init(void);
 void omap_nand_switch_ecc(int);
 void am33xx_spl_board_init(void);
+int am335x_get_efuse_mpu_max_freq(struct ctrl_dev *cdev);
+int am335x_get_tps65910_mpu_vdd(int sil_rev, int frequency);
 #endif
diff --git a/arch/arm/include/asm/arch-omap3/mux.h b/arch/arm/include/asm/arch-omap3/mux.h
index 6e92b23..310765b 100644
--- a/arch/arm/include/asm/arch-omap3/mux.h
+++ b/arch/arm/include/asm/arch-omap3/mux.h
@@ -1,464 +1,168 @@
-/*
- * (C) Copyright 2006-2008
- * Texas Instruments, <www.ti.com>
- * Syed Mohammed Khasim <x0khasim@ti.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef _MUX_H_
-#define _MUX_H_
-
-/*
- * IEN  - Input Enable
- * IDIS - Input Disable
- * PTD  - Pull type Down
- * PTU  - Pull type Up
- * DIS  - Pull type selection is inactive
- * EN   - Pull type selection is active
- * M0   - Mode 0
- */
-
-#define IEN	(1 << 8)
-
-#define IDIS	(0 << 8)
-#define PTU	(1 << 4)
-#define PTD	(0 << 4)
-#define EN	(1 << 3)
-#define DIS	(0 << 3)
-
-#define M0	0
-#define M1	1
-#define M2	2
-#define M3	3
-#define M4	4
-#define M5	5
-#define M6	6
-#define M7	7
-
-/*
- * To get the actual address the offset has to added
- * with OMAP34XX_CTRL_BASE to get the actual address
- */
-
-/*SDRC*/
-#define CONTROL_PADCONF_SDRC_D0		0x0030
-#define CONTROL_PADCONF_SDRC_D1		0x0032
-#define CONTROL_PADCONF_SDRC_D2		0x0034
-#define CONTROL_PADCONF_SDRC_D3		0x0036
-#define CONTROL_PADCONF_SDRC_D4		0x0038
-#define CONTROL_PADCONF_SDRC_D5		0x003A
-#define CONTROL_PADCONF_SDRC_D6		0x003C
-#define CONTROL_PADCONF_SDRC_D7		0x003E
-#define CONTROL_PADCONF_SDRC_D8		0x0040
-#define CONTROL_PADCONF_SDRC_D9		0x0042
-#define CONTROL_PADCONF_SDRC_D10	0x0044
-#define CONTROL_PADCONF_SDRC_D11	0x0046
-#define CONTROL_PADCONF_SDRC_D12	0x0048
-#define CONTROL_PADCONF_SDRC_D13	0x004A
-#define CONTROL_PADCONF_SDRC_D14	0x004C
-#define CONTROL_PADCONF_SDRC_D15	0x004E
-#define CONTROL_PADCONF_SDRC_D16	0x0050
-#define CONTROL_PADCONF_SDRC_D17	0x0052
-#define CONTROL_PADCONF_SDRC_D18	0x0054
-#define CONTROL_PADCONF_SDRC_D19	0x0056
-#define CONTROL_PADCONF_SDRC_D20	0x0058
-#define CONTROL_PADCONF_SDRC_D21	0x005A
-#define CONTROL_PADCONF_SDRC_D22	0x005C
-#define CONTROL_PADCONF_SDRC_D23	0x005E
-#define CONTROL_PADCONF_SDRC_D24	0x0060
-#define CONTROL_PADCONF_SDRC_D25	0x0062
-#define CONTROL_PADCONF_SDRC_D26	0x0064
-#define CONTROL_PADCONF_SDRC_D27	0x0066
-#define CONTROL_PADCONF_SDRC_D28	0x0068
-#define CONTROL_PADCONF_SDRC_D29	0x006A
-#define CONTROL_PADCONF_SDRC_D30	0x006C
-#define CONTROL_PADCONF_SDRC_D31	0x006E
-#define CONTROL_PADCONF_SDRC_CLK	0x0070
-#define CONTROL_PADCONF_SDRC_DQS0	0x0072
-#define CONTROL_PADCONF_SDRC_DQS1	0x0074
-#define CONTROL_PADCONF_SDRC_DQS2	0x0076
-#define CONTROL_PADCONF_SDRC_DQS3	0x0078
-/*GPMC*/
-#define CONTROL_PADCONF_GPMC_A1		0x007A
-#define CONTROL_PADCONF_GPMC_A2		0x007C
-#define CONTROL_PADCONF_GPMC_A3		0x007E
-#define CONTROL_PADCONF_GPMC_A4		0x0080
-#define CONTROL_PADCONF_GPMC_A5		0x0082
-#define CONTROL_PADCONF_GPMC_A6		0x0084
-#define CONTROL_PADCONF_GPMC_A7		0x0086
-#define CONTROL_PADCONF_GPMC_A8		0x0088
-#define CONTROL_PADCONF_GPMC_A9		0x008A
-#define CONTROL_PADCONF_GPMC_A10	0x008C
-#define CONTROL_PADCONF_GPMC_D0		0x008E
-#define CONTROL_PADCONF_GPMC_D1		0x0090
-#define CONTROL_PADCONF_GPMC_D2		0x0092
-#define CONTROL_PADCONF_GPMC_D3		0x0094
-#define CONTROL_PADCONF_GPMC_D4		0x0096
-#define CONTROL_PADCONF_GPMC_D5		0x0098
-#define CONTROL_PADCONF_GPMC_D6		0x009A
-#define CONTROL_PADCONF_GPMC_D7		0x009C
-#define CONTROL_PADCONF_GPMC_D8		0x009E
-#define CONTROL_PADCONF_GPMC_D9		0x00A0
-#define CONTROL_PADCONF_GPMC_D10	0x00A2
-#define CONTROL_PADCONF_GPMC_D11	0x00A4
-#define CONTROL_PADCONF_GPMC_D12	0x00A6
-#define CONTROL_PADCONF_GPMC_D13	0x00A8
-#define CONTROL_PADCONF_GPMC_D14	0x00AA
-#define CONTROL_PADCONF_GPMC_D15	0x00AC
-#define CONTROL_PADCONF_GPMC_NCS0	0x00AE
-#define CONTROL_PADCONF_GPMC_NCS1	0x00B0
-#define CONTROL_PADCONF_GPMC_NCS2	0x00B2
-#define CONTROL_PADCONF_GPMC_NCS3	0x00B4
-#define CONTROL_PADCONF_GPMC_NCS4	0x00B6
-#define CONTROL_PADCONF_GPMC_NCS5	0x00B8
-#define CONTROL_PADCONF_GPMC_NCS6	0x00BA
-#define CONTROL_PADCONF_GPMC_NCS7	0x00BC
-#define CONTROL_PADCONF_GPMC_CLK	0x00BE
-#define CONTROL_PADCONF_GPMC_NADV_ALE	0x00C0
-#define CONTROL_PADCONF_GPMC_NOE	0x00C2
-#define CONTROL_PADCONF_GPMC_NWE	0x00C4
-#define CONTROL_PADCONF_GPMC_NBE0_CLE	0x00C6
-#define CONTROL_PADCONF_GPMC_NBE1	0x00C8
-#define CONTROL_PADCONF_GPMC_NWP	0x00CA
-#define CONTROL_PADCONF_GPMC_WAIT0	0x00CC
-#define CONTROL_PADCONF_GPMC_WAIT1	0x00CE
-#define CONTROL_PADCONF_GPMC_WAIT2	0x00D0
-#define CONTROL_PADCONF_GPMC_WAIT3	0x00D2
-/*DSS*/
-#define CONTROL_PADCONF_DSS_PCLK	0x00D4
-#define CONTROL_PADCONF_DSS_HSYNC	0x00D6
-#define CONTROL_PADCONF_DSS_VSYNC	0x00D8
-#define CONTROL_PADCONF_DSS_ACBIAS	0x00DA
-#define CONTROL_PADCONF_DSS_DATA0	0x00DC
-#define CONTROL_PADCONF_DSS_DATA1	0x00DE
-#define CONTROL_PADCONF_DSS_DATA2	0x00E0
-#define CONTROL_PADCONF_DSS_DATA3	0x00E2
-#define CONTROL_PADCONF_DSS_DATA4	0x00E4
-#define CONTROL_PADCONF_DSS_DATA5	0x00E6
-#define CONTROL_PADCONF_DSS_DATA6	0x00E8
-#define CONTROL_PADCONF_DSS_DATA7	0x00EA
-#define CONTROL_PADCONF_DSS_DATA8	0x00EC
-#define CONTROL_PADCONF_DSS_DATA9	0x00EE
-#define CONTROL_PADCONF_DSS_DATA10	0x00F0
-#define CONTROL_PADCONF_DSS_DATA11	0x00F2
-#define CONTROL_PADCONF_DSS_DATA12	0x00F4
-#define CONTROL_PADCONF_DSS_DATA13	0x00F6
-#define CONTROL_PADCONF_DSS_DATA14	0x00F8
-#define CONTROL_PADCONF_DSS_DATA15	0x00FA
-#define CONTROL_PADCONF_DSS_DATA16	0x00FC
-#define CONTROL_PADCONF_DSS_DATA17	0x00FE
-#define CONTROL_PADCONF_DSS_DATA18	0x0100
-#define CONTROL_PADCONF_DSS_DATA19	0x0102
-#define CONTROL_PADCONF_DSS_DATA20	0x0104
-#define CONTROL_PADCONF_DSS_DATA21	0x0106
-#define CONTROL_PADCONF_DSS_DATA22	0x0108
-#define CONTROL_PADCONF_DSS_DATA23	0x010A
-/*CAMERA*/
-#define CONTROL_PADCONF_CAM_HS		0x010C
-#define CONTROL_PADCONF_CAM_VS		0x010E
-#define CONTROL_PADCONF_CAM_XCLKA	0x0110
-#define CONTROL_PADCONF_CAM_PCLK	0x0112
-#define CONTROL_PADCONF_CAM_FLD		0x0114
-#define CONTROL_PADCONF_CAM_D0		0x0116
-#define CONTROL_PADCONF_CAM_D1		0x0118
-#define CONTROL_PADCONF_CAM_D2		0x011A
-#define CONTROL_PADCONF_CAM_D3		0x011C
-#define CONTROL_PADCONF_CAM_D4		0x011E
-#define CONTROL_PADCONF_CAM_D5		0x0120
-#define CONTROL_PADCONF_CAM_D6		0x0122
-#define CONTROL_PADCONF_CAM_D7		0x0124
-#define CONTROL_PADCONF_CAM_D8		0x0126
-#define CONTROL_PADCONF_CAM_D9		0x0128
-#define CONTROL_PADCONF_CAM_D10		0x012A
-#define CONTROL_PADCONF_CAM_D11		0x012C
-#define CONTROL_PADCONF_CAM_XCLKB	0x012E
-#define CONTROL_PADCONF_CAM_WEN		0x0130
-#define CONTROL_PADCONF_CAM_STROBE	0x0132
-#define CONTROL_PADCONF_CSI2_DX0	0x0134
-#define CONTROL_PADCONF_CSI2_DY0	0x0136
-#define CONTROL_PADCONF_CSI2_DX1	0x0138
-#define CONTROL_PADCONF_CSI2_DY1	0x013A
-/*Audio Interface */
-#define CONTROL_PADCONF_MCBSP2_FSX	0x013C
-#define CONTROL_PADCONF_MCBSP2_CLKX	0x013E
-#define CONTROL_PADCONF_MCBSP2_DR	0x0140
-#define CONTROL_PADCONF_MCBSP2_DX	0x0142
-#define CONTROL_PADCONF_MMC1_CLK	0x0144
-#define CONTROL_PADCONF_MMC1_CMD	0x0146
-#define CONTROL_PADCONF_MMC1_DAT0	0x0148
-#define CONTROL_PADCONF_MMC1_DAT1	0x014A
-#define CONTROL_PADCONF_MMC1_DAT2	0x014C
-#define CONTROL_PADCONF_MMC1_DAT3	0x014E
-#define CONTROL_PADCONF_MMC1_DAT4	0x0150
-#define CONTROL_PADCONF_MMC1_DAT5	0x0152
-#define CONTROL_PADCONF_MMC1_DAT6	0x0154
-#define CONTROL_PADCONF_MMC1_DAT7	0x0156
-/*Wireless LAN */
-#define CONTROL_PADCONF_MMC2_CLK	0x0158
-#define CONTROL_PADCONF_MMC2_CMD	0x015A
-#define CONTROL_PADCONF_MMC2_DAT0	0x015C
-#define CONTROL_PADCONF_MMC2_DAT1	0x015E
-#define CONTROL_PADCONF_MMC2_DAT2	0x0160
-#define CONTROL_PADCONF_MMC2_DAT3	0x0162
-#define CONTROL_PADCONF_MMC2_DAT4	0x0164
-#define CONTROL_PADCONF_MMC2_DAT5	0x0166
-#define CONTROL_PADCONF_MMC2_DAT6	0x0168
-#define CONTROL_PADCONF_MMC2_DAT7	0x016A
-/*Bluetooth*/
-#define CONTROL_PADCONF_MCBSP3_DX	0x016C
-#define CONTROL_PADCONF_MCBSP3_DR	0x016E
-#define CONTROL_PADCONF_MCBSP3_CLKX	0x0170
-#define CONTROL_PADCONF_MCBSP3_FSX	0x0172
-#define CONTROL_PADCONF_UART2_CTS	0x0174
-#define CONTROL_PADCONF_UART2_RTS	0x0176
-#define CONTROL_PADCONF_UART2_TX	0x0178
-#define CONTROL_PADCONF_UART2_RX	0x017A
-/*Modem Interface */
-#define CONTROL_PADCONF_UART1_TX	0x017C
-#define CONTROL_PADCONF_UART1_RTS	0x017E
-#define CONTROL_PADCONF_UART1_CTS	0x0180
-#define CONTROL_PADCONF_UART1_RX	0x0182
-#define CONTROL_PADCONF_MCBSP4_CLKX	0x0184
-#define CONTROL_PADCONF_MCBSP4_DR	0x0186
-#define CONTROL_PADCONF_MCBSP4_DX	0x0188
-#define CONTROL_PADCONF_MCBSP4_FSX	0x018A
-#define CONTROL_PADCONF_MCBSP1_CLKR	0x018C
-#define CONTROL_PADCONF_MCBSP1_FSR	0x018E
-#define CONTROL_PADCONF_MCBSP1_DX	0x0190
-#define CONTROL_PADCONF_MCBSP1_DR	0x0192
-#define CONTROL_PADCONF_MCBSP_CLKS	0x0194
-#define CONTROL_PADCONF_MCBSP1_FSX	0x0196
-#define CONTROL_PADCONF_MCBSP1_CLKX	0x0198
-/*Serial Interface*/
-#define CONTROL_PADCONF_UART3_CTS_RCTX	0x019A
-#define CONTROL_PADCONF_UART3_RTS_SD	0x019C
-#define CONTROL_PADCONF_UART3_RX_IRRX	0x019E
-#define CONTROL_PADCONF_UART3_TX_IRTX	0x01A0
-#define CONTROL_PADCONF_HSUSB0_CLK	0x01A2
-#define CONTROL_PADCONF_HSUSB0_STP	0x01A4
-#define CONTROL_PADCONF_HSUSB0_DIR	0x01A6
-#define CONTROL_PADCONF_HSUSB0_NXT	0x01A8
-#define CONTROL_PADCONF_HSUSB0_DATA0	0x01AA
-#define CONTROL_PADCONF_HSUSB0_DATA1	0x01AC
-#define CONTROL_PADCONF_HSUSB0_DATA2	0x01AE
-#define CONTROL_PADCONF_HSUSB0_DATA3	0x01B0
-#define CONTROL_PADCONF_HSUSB0_DATA4	0x01B2
-#define CONTROL_PADCONF_HSUSB0_DATA5	0x01B4
-#define CONTROL_PADCONF_HSUSB0_DATA6	0x01B6
-#define CONTROL_PADCONF_HSUSB0_DATA7	0x01B8
-#define CONTROL_PADCONF_I2C1_SCL	0x01BA
-#define CONTROL_PADCONF_I2C1_SDA	0x01BC
-#define CONTROL_PADCONF_I2C2_SCL	0x01BE
-#define CONTROL_PADCONF_I2C2_SDA	0x01C0
-#define CONTROL_PADCONF_I2C3_SCL	0x01C2
-#define CONTROL_PADCONF_I2C3_SDA	0x01C4
-#define CONTROL_PADCONF_I2C4_SCL	0x0A00
-#define CONTROL_PADCONF_I2C4_SDA	0x0A02
-#define CONTROL_PADCONF_HDQ_SIO		0x01C6
-#define CONTROL_PADCONF_MCSPI1_CLK	0x01C8
-#define CONTROL_PADCONF_MCSPI1_SIMO	0x01CA
-#define CONTROL_PADCONF_MCSPI1_SOMI	0x01CC
-#define CONTROL_PADCONF_MCSPI1_CS0	0x01CE
-#define CONTROL_PADCONF_MCSPI1_CS1	0x01D0
-#define CONTROL_PADCONF_MCSPI1_CS2	0x01D2
-#define CONTROL_PADCONF_MCSPI1_CS3	0x01D4
-#define CONTROL_PADCONF_MCSPI2_CLK	0x01D6
-#define CONTROL_PADCONF_MCSPI2_SIMO	0x01D8
-#define CONTROL_PADCONF_MCSPI2_SOMI	0x01DA
-#define CONTROL_PADCONF_MCSPI2_CS0	0x01DC
-#define CONTROL_PADCONF_MCSPI2_CS1	0x01DE
-/*Control and debug */
-#define CONTROL_PADCONF_SYS_32K		0x0A04
-#define CONTROL_PADCONF_SYS_CLKREQ	0x0A06
-#define CONTROL_PADCONF_SYS_NIRQ	0x01E0
-#define CONTROL_PADCONF_SYS_BOOT0	0x0A0A
-#define CONTROL_PADCONF_SYS_BOOT1	0x0A0C
-#define CONTROL_PADCONF_SYS_BOOT2	0x0A0E
-#define CONTROL_PADCONF_SYS_BOOT3	0x0A10
-#define CONTROL_PADCONF_SYS_BOOT4	0x0A12
-#define CONTROL_PADCONF_SYS_BOOT5	0x0A14
-#define CONTROL_PADCONF_SYS_BOOT6	0x0A16
-#define CONTROL_PADCONF_SYS_OFF_MODE	0x0A18
-#define CONTROL_PADCONF_SYS_CLKOUT1	0x0A1A
-#define CONTROL_PADCONF_SYS_CLKOUT2	0x01E2
-#define CONTROL_PADCONF_JTAG_nTRST	0x0A1C
-#define CONTROL_PADCONF_JTAG_TCK	0x0A1E
-#define CONTROL_PADCONF_JTAG_TMS	0x0A20
-#define CONTROL_PADCONF_JTAG_TDI	0x0A22
-#define CONTROL_PADCONF_JTAG_EMU0	0x0A24
-#define CONTROL_PADCONF_JTAG_EMU1	0x0A26
-#define CONTROL_PADCONF_ETK_CLK		0x0A28
-#define CONTROL_PADCONF_ETK_CTL		0x0A2A
-#define CONTROL_PADCONF_ETK_D0		0x0A2C
-#define CONTROL_PADCONF_ETK_D1		0x0A2E
-#define CONTROL_PADCONF_ETK_D2		0x0A30
-#define CONTROL_PADCONF_ETK_D3		0x0A32
-#define CONTROL_PADCONF_ETK_D4		0x0A34
-#define CONTROL_PADCONF_ETK_D5		0x0A36
-#define CONTROL_PADCONF_ETK_D6		0x0A38
-#define CONTROL_PADCONF_ETK_D7		0x0A3A
-#define CONTROL_PADCONF_ETK_D8		0x0A3C
-#define CONTROL_PADCONF_ETK_D9		0x0A3E
-#define CONTROL_PADCONF_ETK_D10		0x0A40
-#define CONTROL_PADCONF_ETK_D11		0x0A42
-#define CONTROL_PADCONF_ETK_D12		0x0A44
-#define CONTROL_PADCONF_ETK_D13		0x0A46
-#define CONTROL_PADCONF_ETK_D14		0x0A48
-#define CONTROL_PADCONF_ETK_D15		0x0A4A
-#define CONTROL_PADCONF_ETK_CLK_ES2	0x05D8
-#define CONTROL_PADCONF_ETK_CTL_ES2	0x05DA
-#define CONTROL_PADCONF_ETK_D0_ES2	0x05DC
-#define CONTROL_PADCONF_ETK_D1_ES2	0x05DE
-#define CONTROL_PADCONF_ETK_D2_ES2	0x05E0
-#define CONTROL_PADCONF_ETK_D3_ES2	0x05E2
-#define CONTROL_PADCONF_ETK_D4_ES2	0x05E4
-#define CONTROL_PADCONF_ETK_D5_ES2	0x05E6
-#define CONTROL_PADCONF_ETK_D6_ES2	0x05E8
-#define CONTROL_PADCONF_ETK_D7_ES2	0x05EA
-#define CONTROL_PADCONF_ETK_D8_ES2	0x05EC
-#define CONTROL_PADCONF_ETK_D9_ES2	0x05EE
-#define CONTROL_PADCONF_ETK_D10_ES2	0x05F0
-#define CONTROL_PADCONF_ETK_D11_ES2	0x05F2
-#define CONTROL_PADCONF_ETK_D12_ES2	0x05F4
-#define CONTROL_PADCONF_ETK_D13_ES2	0x05F6
-#define CONTROL_PADCONF_ETK_D14_ES2	0x05F8
-#define CONTROL_PADCONF_ETK_D15_ES2	0x05FA
-/*Die to Die */
-#define CONTROL_PADCONF_D2D_MCAD0	0x01E4
-#define CONTROL_PADCONF_D2D_MCAD1	0x01E6
-#define CONTROL_PADCONF_D2D_MCAD2	0x01E8
-#define CONTROL_PADCONF_D2D_MCAD3	0x01EA
-#define CONTROL_PADCONF_D2D_MCAD4	0x01EC
-#define CONTROL_PADCONF_D2D_MCAD5	0x01EE
-#define CONTROL_PADCONF_D2D_MCAD6	0x01F0
-#define CONTROL_PADCONF_D2D_MCAD7	0x01F2
-#define CONTROL_PADCONF_D2D_MCAD8	0x01F4
-#define CONTROL_PADCONF_D2D_MCAD9	0x01F6
-#define CONTROL_PADCONF_D2D_MCAD10	0x01F8
-#define CONTROL_PADCONF_D2D_MCAD11	0x01FA
-#define CONTROL_PADCONF_D2D_MCAD12	0x01FC
-#define CONTROL_PADCONF_D2D_MCAD13	0x01FE
-#define CONTROL_PADCONF_D2D_MCAD14	0x0200
-#define CONTROL_PADCONF_D2D_MCAD15	0x0202
-#define CONTROL_PADCONF_D2D_MCAD16	0x0204
-#define CONTROL_PADCONF_D2D_MCAD17	0x0206
-#define CONTROL_PADCONF_D2D_MCAD18	0x0208
-#define CONTROL_PADCONF_D2D_MCAD19	0x020A
-#define CONTROL_PADCONF_D2D_MCAD20	0x020C
-#define CONTROL_PADCONF_D2D_MCAD21	0x020E
-#define CONTROL_PADCONF_D2D_MCAD22	0x0210
-#define CONTROL_PADCONF_D2D_MCAD23	0x0212
-#define CONTROL_PADCONF_D2D_MCAD24	0x0214
-#define CONTROL_PADCONF_D2D_MCAD25	0x0216
-#define CONTROL_PADCONF_D2D_MCAD26	0x0218
-#define CONTROL_PADCONF_D2D_MCAD27	0x021A
-#define CONTROL_PADCONF_D2D_MCAD28	0x021C
-#define CONTROL_PADCONF_D2D_MCAD29	0x021E
-#define CONTROL_PADCONF_D2D_MCAD30	0x0220
-#define CONTROL_PADCONF_D2D_MCAD31	0x0222
-#define CONTROL_PADCONF_D2D_MCAD32	0x0224
-#define CONTROL_PADCONF_D2D_MCAD33	0x0226
-#define CONTROL_PADCONF_D2D_MCAD34	0x0228
-#define CONTROL_PADCONF_D2D_MCAD35	0x022A
-#define CONTROL_PADCONF_D2D_MCAD36	0x022C
-#define CONTROL_PADCONF_D2D_CLK26MI	0x022E
-#define CONTROL_PADCONF_D2D_NRESPWRON	0x0230
-#define CONTROL_PADCONF_D2D_NRESWARM	0x0232
-#define CONTROL_PADCONF_D2D_ARM9NIRQ	0x0234
-#define CONTROL_PADCONF_D2D_UMA2P6FIQ	0x0236
-#define CONTROL_PADCONF_D2D_SPINT	0x0238
-#define CONTROL_PADCONF_D2D_FRINT	0x023A
-#define CONTROL_PADCONF_D2D_DMAREQ0	0x023C
-#define CONTROL_PADCONF_D2D_DMAREQ1	0x023E
-#define CONTROL_PADCONF_D2D_DMAREQ2	0x0240
-#define CONTROL_PADCONF_D2D_DMAREQ3	0x0242
-#define CONTROL_PADCONF_D2D_N3GTRST	0x0244
-#define CONTROL_PADCONF_D2D_N3GTDI	0x0246
-#define CONTROL_PADCONF_D2D_N3GTDO	0x0248
-#define CONTROL_PADCONF_D2D_N3GTMS	0x024A
-#define CONTROL_PADCONF_D2D_N3GTCK	0x024C
-#define CONTROL_PADCONF_D2D_N3GRTCK	0x024E
-#define CONTROL_PADCONF_D2D_MSTDBY	0x0250
-#define CONTROL_PADCONF_D2D_SWAKEUP	0x0A4C
-#define CONTROL_PADCONF_D2D_IDLEREQ	0x0252
-#define CONTROL_PADCONF_D2D_IDLEACK	0x0254
-#define CONTROL_PADCONF_D2D_MWRITE	0x0256
-#define CONTROL_PADCONF_D2D_SWRITE	0x0258
-#define CONTROL_PADCONF_D2D_MREAD	0x025A
-#define CONTROL_PADCONF_D2D_SREAD	0x025C
-#define CONTROL_PADCONF_D2D_MBUSFLAG	0x025E
-#define CONTROL_PADCONF_D2D_SBUSFLAG	0x0260
-#define CONTROL_PADCONF_SDRC_CKE0	0x0262
-#define CONTROL_PADCONF_SDRC_CKE1	0x0264
-
-/* AM3517 specific mux configuration */
-#define CONTROL_PADCONF_SYS_NRESWARM	0x0A08
-/* CCDC */
-#define CONTROL_PADCONF_CCDC_PCLK	0x01E4
-#define CONTROL_PADCONF_CCDC_FIELD	0x01E6
-#define CONTROL_PADCONF_CCDC_HD		0x01E8
-#define CONTROL_PADCONF_CCDC_VD		0x01EA
-#define CONTROL_PADCONF_CCDC_WEN	0x01EC
-#define CONTROL_PADCONF_CCDC_DATA0	0x01EE
-#define CONTROL_PADCONF_CCDC_DATA1	0x01F0
-#define CONTROL_PADCONF_CCDC_DATA2	0x01F2
-#define CONTROL_PADCONF_CCDC_DATA3	0x01F4
-#define CONTROL_PADCONF_CCDC_DATA4	0x01F6
-#define CONTROL_PADCONF_CCDC_DATA5	0x01F8
-#define CONTROL_PADCONF_CCDC_DATA6	0x01FA
-#define CONTROL_PADCONF_CCDC_DATA7	0x01FC
-/* RMII */
-#define CONTROL_PADCONF_RMII_MDIO_DATA	0x01FE
-#define CONTROL_PADCONF_RMII_MDIO_CLK	0x0200
-#define CONTROL_PADCONF_RMII_RXD0	0x0202
-#define CONTROL_PADCONF_RMII_RXD1	0x0204
-#define CONTROL_PADCONF_RMII_CRS_DV	0x0206
-#define CONTROL_PADCONF_RMII_RXER	0x0208
-#define CONTROL_PADCONF_RMII_TXD0	0x020A
-#define CONTROL_PADCONF_RMII_TXD1	0x020C
-#define CONTROL_PADCONF_RMII_TXEN	0x020E
-#define CONTROL_PADCONF_RMII_50MHZ_CLK	0x0210
-#define CONTROL_PADCONF_USB0_DRVBUS	0x0212
-/* CAN */
-#define CONTROL_PADCONF_HECC1_TXD	0x0214
-#define CONTROL_PADCONF_HECC1_RXD	0x0216
-
-#define CONTROL_PADCONF_SYS_BOOT7	0x0218
-#define CONTROL_PADCONF_SDRC_DQS0N	0x021A
-#define CONTROL_PADCONF_SDRC_DQS1N	0x021C
-#define CONTROL_PADCONF_SDRC_DQS2N	0x021E
-#define CONTROL_PADCONF_SDRC_DQS3N	0x0220
-#define CONTROL_PADCONF_STRBEN_DLY0	0x0222
-#define CONTROL_PADCONF_STRBEN_DLY1	0x0224
-#define CONTROL_PADCONF_SYS_BOOT8	0x0226
-
-/* AM/DM37xx specific */
-#define CONTROL_PADCONF_GPIO127		0x0A54
-#define CONTROL_PADCONF_GPIO126		0x0A56
-#define CONTROL_PADCONF_GPIO128		0x0A58
-#define CONTROL_PADCONF_GPIO129		0x0A5A
-
-/* AM/DM37xx specific: gpio_127, gpio_127 and gpio_129 require configuration
- * of the extended drain cells */
-#define OMAP34XX_CTRL_WKUP_CTRL		(OMAP34XX_CTRL_BASE + 0x0A5C)
-#define OMAP34XX_CTRL_WKUP_CTRL_GPIO_IO_PWRDNZ	(1<<6)
-
-#define MUX_VAL(OFFSET,VALUE)\
-	writew((VALUE), OMAP34XX_CTRL_BASE + (OFFSET));
-
-#define	CP(x)	(CONTROL_PADCONF_##x)
-
-#endif
+#ifndef _MUX_H_
+#define _MUX_H_
+
+/*
+ * MODE0 - Mux Mode 0
+ * MODE1 - Mux Mode 1
+ * MODE2 - Mux Mode 2
+ * MODE3 - Mux Mode 3
+ * MODE4 - Mux Mode 4
+ * MODE5 - Mux Mode 5
+ * MODE6 - Mux Mode 6
+ * MODE7 - Mux Mode 7
+ * IDIS - Receiver disabled
+ * IEN - Receiver enabled
+ * PD - Internal pull-down
+ * PU - Internal pull-up
+ * OFF - Internal pull disabled
+ */
+
+#define MODE0 0
+#define MODE1 1
+#define MODE2 2
+#define MODE3 3
+#define MODE4 4
+#define MODE5 5
+#define MODE6 6
+#define MODE7 7
+#define IDIS (0 << 5)
+#define IEN (1 << 5)
+#define PD (0 << 3)
+#define PU (2 << 3)
+#define OFF (1 << 3)
+
+/*
+ * To get the physical address the offset has
+ * to be added to AM335X_CTRL_BASE
+ */
+
+#define CONTROL_PADCONF_GPMC_AD0                  0x0800
+#define CONTROL_PADCONF_GPMC_AD1                  0x0804
+#define CONTROL_PADCONF_GPMC_AD2                  0x0808
+#define CONTROL_PADCONF_GPMC_AD3                  0x080C
+#define CONTROL_PADCONF_GPMC_AD4                  0x0810
+#define CONTROL_PADCONF_GPMC_AD5                  0x0814
+#define CONTROL_PADCONF_GPMC_AD6                  0x0818
+#define CONTROL_PADCONF_GPMC_AD7                  0x081C
+#define CONTROL_PADCONF_GPMC_AD8                  0x0820
+#define CONTROL_PADCONF_GPMC_AD9                  0x0824
+#define CONTROL_PADCONF_GPMC_AD10                 0x0828
+#define CONTROL_PADCONF_GPMC_AD11                 0x082C
+#define CONTROL_PADCONF_GPMC_AD12                 0x0830
+#define CONTROL_PADCONF_GPMC_AD13                 0x0834
+#define CONTROL_PADCONF_GPMC_AD14                 0x0838
+#define CONTROL_PADCONF_GPMC_AD15                 0x083C
+#define CONTROL_PADCONF_GPMC_A0                   0x0840
+#define CONTROL_PADCONF_GPMC_A1                   0x0844
+#define CONTROL_PADCONF_GPMC_A2                   0x0848
+#define CONTROL_PADCONF_GPMC_A3                   0x084C
+#define CONTROL_PADCONF_GPMC_A4                   0x0850
+#define CONTROL_PADCONF_GPMC_A5                   0x0854
+#define CONTROL_PADCONF_GPMC_A6                   0x0858
+#define CONTROL_PADCONF_GPMC_A7                   0x085C
+#define CONTROL_PADCONF_GPMC_A8                   0x0860
+#define CONTROL_PADCONF_GPMC_A9                   0x0864
+#define CONTROL_PADCONF_GPMC_A10                  0x0868
+#define CONTROL_PADCONF_GPMC_A11                  0x086C
+#define CONTROL_PADCONF_GPMC_WAIT0                0x0870
+#define CONTROL_PADCONF_GPMC_WPN                  0x0874
+#define CONTROL_PADCONF_GPMC_BEN1                 0x0878
+#define CONTROL_PADCONF_GPMC_CSN0                 0x087C
+#define CONTROL_PADCONF_GPMC_CSN1                 0x0880
+#define CONTROL_PADCONF_GPMC_CSN2                 0x0884
+#define CONTROL_PADCONF_GPMC_CSN3                 0x0888
+#define CONTROL_PADCONF_GPMC_CLK                  0x088C
+#define CONTROL_PADCONF_GPMC_ADVN_ALE             0x0890
+#define CONTROL_PADCONF_GPMC_OEN_REN              0x0894
+#define CONTROL_PADCONF_GPMC_WEN                  0x0898
+#define CONTROL_PADCONF_GPMC_BEN0_CLE             0x089C
+#define CONTROL_PADCONF_LCD_DATA0                 0x08A0
+#define CONTROL_PADCONF_LCD_DATA1                 0x08A4
+#define CONTROL_PADCONF_LCD_DATA2                 0x08A8
+#define CONTROL_PADCONF_LCD_DATA3                 0x08AC
+#define CONTROL_PADCONF_LCD_DATA4                 0x08B0
+#define CONTROL_PADCONF_LCD_DATA5                 0x08B4
+#define CONTROL_PADCONF_LCD_DATA6                 0x08B8
+#define CONTROL_PADCONF_LCD_DATA7                 0x08BC
+#define CONTROL_PADCONF_LCD_DATA8                 0x08C0
+#define CONTROL_PADCONF_LCD_DATA9                 0x08C4
+#define CONTROL_PADCONF_LCD_DATA10                0x08C8
+#define CONTROL_PADCONF_LCD_DATA11                0x08CC
+#define CONTROL_PADCONF_LCD_DATA12                0x08D0
+#define CONTROL_PADCONF_LCD_DATA13                0x08D4
+#define CONTROL_PADCONF_LCD_DATA14                0x08D8
+#define CONTROL_PADCONF_LCD_DATA15                0x08DC
+#define CONTROL_PADCONF_LCD_VSYNC                 0x08E0
+#define CONTROL_PADCONF_LCD_HSYNC                 0x08E4
+#define CONTROL_PADCONF_LCD_PCLK                  0x08E8
+#define CONTROL_PADCONF_LCD_AC_BIAS_EN            0x08EC
+#define CONTROL_PADCONF_MMC0_DAT3                 0x08F0
+#define CONTROL_PADCONF_MMC0_DAT2                 0x08F4
+#define CONTROL_PADCONF_MMC0_DAT1                 0x08F8
+#define CONTROL_PADCONF_MMC0_DAT0                 0x08FC
+#define CONTROL_PADCONF_MMC0_CLK                  0x0900
+#define CONTROL_PADCONF_MMC0_CMD                  0x0904
+#define CONTROL_PADCONF_MII1_COL                  0x0908
+#define CONTROL_PADCONF_MII1_CRS                  0x090C
+#define CONTROL_PADCONF_MII1_RX_ER                0x0910
+#define CONTROL_PADCONF_MII1_TX_EN                0x0914
+#define CONTROL_PADCONF_MII1_RX_DV                0x0918
+#define CONTROL_PADCONF_MII1_TXD3                 0x091C
+#define CONTROL_PADCONF_MII1_TXD2                 0x0920
+#define CONTROL_PADCONF_MII1_TXD1                 0x0924
+#define CONTROL_PADCONF_MII1_TXD0                 0x0928
+#define CONTROL_PADCONF_MII1_TX_CLK               0x092C
+#define CONTROL_PADCONF_MII1_RX_CLK               0x0930
+#define CONTROL_PADCONF_MII1_RXD3                 0x0934
+#define CONTROL_PADCONF_MII1_RXD2                 0x0938
+#define CONTROL_PADCONF_MII1_RXD1                 0x093C
+#define CONTROL_PADCONF_MII1_RXD0                 0x0940
+#define CONTROL_PADCONF_RMII1_REF_CLK             0x0944
+#define CONTROL_PADCONF_MDIO                      0x0948
+#define CONTROL_PADCONF_MDC                       0x094C
+#define CONTROL_PADCONF_SPI0_SCLK                 0x0950
+#define CONTROL_PADCONF_SPI0_D0                   0x0954
+#define CONTROL_PADCONF_SPI0_D1                   0x0958
+#define CONTROL_PADCONF_SPI0_CS0                  0x095C
+#define CONTROL_PADCONF_SPI0_CS1                  0x0960
+#define CONTROL_PADCONF_ECAP0_IN_PWM0_OUT         0x0964
+#define CONTROL_PADCONF_UART0_CTSN                0x0968
+#define CONTROL_PADCONF_UART0_RTSN                0x096C
+#define CONTROL_PADCONF_UART0_RXD                 0x0970
+#define CONTROL_PADCONF_UART0_TXD                 0x0974
+#define CONTROL_PADCONF_UART1_CTSN                0x0978
+#define CONTROL_PADCONF_UART1_RTSN                0x097C
+#define CONTROL_PADCONF_UART1_RXD                 0x0980
+#define CONTROL_PADCONF_UART1_TXD                 0x0984
+#define CONTROL_PADCONF_I2C0_SDA                  0x0988
+#define CONTROL_PADCONF_I2C0_SCL                  0x098C
+#define CONTROL_PADCONF_MCASP0_ACLKX              0x0990
+#define CONTROL_PADCONF_MCASP0_FSX                0x0994
+#define CONTROL_PADCONF_MCASP0_AXR0               0x0998
+#define CONTROL_PADCONF_MCASP0_AHCLKR             0x099C
+#define CONTROL_PADCONF_MCASP0_ACLKR              0x09A0
+#define CONTROL_PADCONF_MCASP0_FSR                0x09A4
+#define CONTROL_PADCONF_MCASP0_AXR1               0x09A8
+#define CONTROL_PADCONF_MCASP0_AHCLKX             0x09AC
+#define CONTROL_PADCONF_XDMA_EVENT_INTR0          0x09B0
+#define CONTROL_PADCONF_XDMA_EVENT_INTR1          0x09B4
+#define CONTROL_PADCONF_WARMRSTN                  0x09B8
+#define CONTROL_PADCONF_EXTINTN                   0x09C0
+#define CONTROL_PADCONF_TMS                       0x09D0
+#define CONTROL_PADCONF_TDI                       0x09D4
+#define CONTROL_PADCONF_TDO                       0x09D8
+#define CONTROL_PADCONF_TCK                       0x09DC
+#define CONTROL_PADCONF_TRSTN                     0x09E0
+#define CONTROL_PADCONF_EMU0                      0x09E4
+#define CONTROL_PADCONF_EMU1                      0x09E8
+#define CONTROL_PADCONF_RTC_PWRONRSTN             0x09F8
+#define CONTROL_PADCONF_PMIC_POWER_EN             0x09FC
+#define CONTROL_PADCONF_EXT_WAKEUP                0x0A00
+#define CONTROL_PADCONF_RTC_KALDO_ENN             0x0A04
+#define CONTROL_PADCONF_USB0_DRVVBUS              0x0A1C
+#define CONTROL_PADCONF_USB1_DRVVBUS              0x0A34
+
+#define MUX_VAL(OFFSET,VALUE)\
+    writel((VALUE), AM335X_CTRL_BASE + (OFFSET));
+
+#endif
diff --git a/arch/arm/include/asm/omap_common.h b/arch/arm/include/asm/omap_common.h
index 9923393..79ccb61 100644
--- a/arch/arm/include/asm/omap_common.h
+++ b/arch/arm/include/asm/omap_common.h
@@ -445,9 +445,9 @@ struct dpll_params {
 	u32 n;
 	s8 m2;
 	s8 m3;
-	s8 m4_h11;
-	s8 m5_h12;
-	s8 m6_h13;
+	s8 m4;
+	s8 m5;
+	s8 m6;
 	s8 m7_h14;
 	s8 h21;
 	s8 h22;
@@ -462,9 +462,9 @@ struct dpll_regs {
 	u32 cm_clksel_dpll;
 	u32 cm_div_m2_dpll;
 	u32 cm_div_m3_dpll;
-	u32 cm_div_m4_h11_dpll;
-	u32 cm_div_m5_h12_dpll;
-	u32 cm_div_m6_h13_dpll;
+	u32 cm_div_m4_dpll;
+	u32 cm_div_m5_dpll;
+	u32 cm_div_m6_dpll;
 	u32 cm_div_m7_h14_dpll;
 	u32 reserved[2];
 	u32 cm_div_h21_dpll;
@@ -530,8 +530,8 @@ void do_enable_clocks(u32 const *clk_domains,
 		      u32 const *clk_modules_explicit_en,
 		      u8 wait_for_enable);
 
-void setup_post_dividers(u32 const base,
-			const struct dpll_params *params);
+//void setup_post_dividers(u32 const base,
+//			const struct dpll_params *params);
 u32 omap_ddr_clk(void);
 u32 get_sys_clk_index(void);
 void enable_basic_clocks(void);
diff --git a/board/cti/dcim/Makefile b/board/cti/dcim/Makefile
new file mode 100644
index 0000000..1795e3e
--- /dev/null
+++ b/board/cti/dcim/Makefile
@@ -0,0 +1,46 @@
+#
+# Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed "as is" WITHOUT ANY WARRANTY of any
+# kind, whether express or implied; without even the implied warranty
+# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_NOR_BOOT),y)
+COBJS	:= mux.o
+endif
+
+COBJS	+= board.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/cti/dcim/board.c b/board/cti/dcim/board.c
new file mode 100644
index 0000000..5f61dea
--- /dev/null
+++ b/board/cti/dcim/board.c
@@ -0,0 +1,627 @@
+/*
+ * board.c
+ *
+ * Common board functions for AM33XX based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/omap_common.h>
+#include <errno.h>
+#include <spl.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clocks_am33xx.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include "board.h"
+#include "pmic.h"
+#include "tps65910.h"
+#include <asm/arch/mem.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct wd_timer *wdtimer = (struct wd_timer *)WDT_BASE;
+struct uart_sys *uart_base = (struct uart_sys *)DEFAULT_UART_BASE;
+
+/* MAIN PLL Fdll = 550 MHz, by default */
+#ifndef CONFIG_SYS_MPUCLK
+#define CONFIG_SYS_MPUCLK       MPUPLL_M_550
+#endif
+
+#define PHY_CONF_REG 22
+#define PHY_CONF_TXCLKEN (1 << 5)
+#define MARVELL_88E15xx 0x1410dd1
+#define MARVELL_MII_PAGE2_MAC_CONTROL 21
+#define MARVELL_MII_PAGE_ADDRESS 22
+
+/* MII mode defines */
+/* b7 - RMII2 clock source: 0 = from PLL, 1 = from chip pin
+ * b6 - RMII1 clock source: 0 = from PLL, 1 = from chip pin
+ * b5 - RGMII2 Internal Delay Mode: 0 = Internal Delay, 1 = No Internal Delay
+ * b4 - RGMII1 Internal Delay Mode: 0 = Internal Delay, 1 = No Internal Delay
+ * b3:2 - Port 2 Mode Select: 00 = GMII/MII, 01 = RMII Mode, 10 = RGMII Mode, 11 = Not Used
+ * b1:0 - Port 1 Mode Select: 00 = GMII/MII, 01 = RMII Mode, 10 = RGMII Mode, 11 = Not Used
+ */
+//#define MII_MODE_ENABLE		0x00
+#define RMII_MODE_ENABLE	0xFD
+#define RGMII_MODE_ENABLE	0xF9
+//0X3A
+
+/* GPIO that controls power to DDR3 VTT */
+#define GPIO_DDR_VTT_EN		7
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+static struct am335x_baseboard_id __attribute__((section (".data"))) header;
+
+/* Needed for EMIF4 module */
+int board_is_evm_15_or_later(void)
+{
+	return 0;
+}
+
+/*
+ * Read header information from EEPROM into global structure.
+ */
+static int read_eeprom(struct am335x_baseboard_id *header)
+{
+	/* Check if baseboard eeprom is available */
+	if (i2c_probe(CONFIG_SYS_I2C_EEPROM_ADDR)) {
+		puts("Could not probe the EEPROM; something fundamentally "
+			"wrong on the I2C bus.\n");
+		return -ENODEV;
+	}
+
+	/* read the eeprom using i2c */
+	if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 2, (uchar *)header,
+		     sizeof(struct am335x_baseboard_id))) {
+		puts("Could not read the EEPROM; something fundamentally"
+			" wrong on the I2C bus.\n");
+		return -EIO;
+	}
+
+	if (header->magic != 0xEE3355AA) {
+		/*
+		 * read the eeprom using i2c again,
+		 * but use only a 1 byte address
+		 */
+		if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 1, (uchar *)header,
+			     sizeof(struct am335x_baseboard_id))) {
+			puts("Could not read the EEPROM; something "
+				"fundamentally wrong on the I2C bus.\n");
+			return -EIO;
+		}
+
+		if (header->magic != 0xEE3355AA) {
+			printf("Incorrect magic number (0x%x) in EEPROM\n",
+					header->magic);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+
+/*
+ * tps65910_set_i2c_control() - Set the TPS65910 to be controlled via the I2C
+ * 				interface.
+ * @return:		       0 on success, not 0 on failure
+ */
+int tps65910_set_i2c_control(void)
+{
+	int ret;
+	uchar buf;
+
+	/* VDD1/2 voltage selection register access by control i/f */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, TPS65910_DEVCTRL_REG, 1,
+		       &buf, 1);
+
+	if (ret)
+		return ret;
+
+	buf |= TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C;
+
+	return i2c_write(TPS65910_CTRL_I2C_ADDR, TPS65910_DEVCTRL_REG, 1,
+			 &buf, 1);
+}
+
+/*
+ * tps65910_voltage_update() - Voltage switching for MPU frequency switching.
+ * @module:		       mpu - 0, core - 1
+ * @vddx_op_vol_sel:	       vdd voltage to set
+ * @return:		       0 on success, not 0 on failure
+ */
+int tps65910_voltage_update(unsigned int module, unsigned char vddx_op_vol_sel)
+{
+	uchar buf;
+	unsigned int reg_offset;
+	int ret;
+
+	if (module == MPU)
+		reg_offset = TPS65910_VDD1_OP_REG;
+	else
+		reg_offset = TPS65910_VDD2_OP_REG;
+
+	/* Select VDDx OP   */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	buf &= ~TPS65910_OP_REG_CMD_MASK;
+
+	ret = i2c_write(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	/* Configure VDDx OP  Voltage */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	buf &= ~TPS65910_OP_REG_SEL_MASK;
+	buf |= vddx_op_vol_sel;
+
+	ret = i2c_write(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	if ((buf & TPS65910_OP_REG_SEL_MASK) != vddx_op_vol_sel)
+		return 1;
+
+	return 0;
+}
+
+
+
+/* UART Defines */
+#define UART_RESET		(0x1 << 1)
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+static void rtc32k_enable(void)
+{
+	struct rtc_regs *rtc = (struct rtc_regs *)AM335X_RTC_BASE;
+
+	/*
+	 * Unlock the RTC's registers.  For more details please see the
+	 * RTC_SS section of the TRM.  In order to unlock we need to
+	 * write these specific values (keys) in this order.
+	 */
+	writel(0x83e70b13, &rtc->kick0r);
+	writel(0x95a4f1e0, &rtc->kick1r);
+
+	/* Enable the RTC 32K OSC by setting bits 3 and 6. */
+	writel((1 << 3) | (1 << 6), &rtc->osc);
+}
+
+
+static const struct ddr_data ddr3_data = {
+	.datardsratio0 = MT41J512M8RH125_RD_DQS,
+	.datawdsratio0 = MT41J512M8RH125_WR_DQS,
+	.datafwsratio0 = MT41J512M8RH125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J512M8RH125_PHY_WR_DATA,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+static const struct cmd_control ddr3_evm_cmd_ctrl_data = {
+	.cmd0csratio = MT41J512M8RH125_RATIO,
+	.cmd0dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J512M8RH125_RATIO,
+	.cmd1dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J512M8RH125_RATIO,
+	.cmd2dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+};
+
+
+
+static struct emif_regs ddr3_evm_emif_reg_data = {
+	.sdram_config = MT41J512M8RH125_EMIF_SDCFG,
+	.ref_ctrl = MT41J512M8RH125_EMIF_SDREF,
+	.sdram_tim1 = MT41J512M8RH125_EMIF_TIM1,
+	.sdram_tim2 = MT41J512M8RH125_EMIF_TIM2,
+	.sdram_tim3 = MT41J512M8RH125_EMIF_TIM3,
+	.zq_config = MT41J512M8RH125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J512M8RH125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	/* break into full u-boot on 'c' */
+	return (serial_tstc() && (serial_getc() == 'c'));
+}
+#endif
+
+const struct dpll_regs dpll_mpu_regs = {
+.cm_clkmode_dpll	= CM_WKUP + 0x88,
+.cm_idlest_dpll	= CM_WKUP + 0x20,
+.cm_clksel_dpll	= CM_WKUP + 0x2C,
+.cm_div_m2_dpll	= CM_WKUP + 0xA8,
+};
+
+void am33xx_spl_board_init(void)
+{
+	struct am335x_baseboard_id header;
+	struct dpll_params dpll_mpu = {0, OSC-1, 1, -1, -1, -1, -1, 0, 0, 0, 0, 0};
+	int mpu_vdd, mpu_pll, sil_rev;
+
+	/* Assume PG 1.0 */
+	mpu_pll = MPUPLL_M_720;
+
+
+		/*
+		 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+		 * MPU frequencies we support we use a CORE voltage of
+		 * 1.1375V.  For MPU voltage we need to switch based on
+		 * the frequency we are running at.
+		 */
+
+		if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		{
+			//printf("$$$ i2c probe returned with error \n");
+			return;
+		}
+
+		/*
+		 * Depending on MPU clock and PG we will need a different
+		 * VDD to drive at that speed.
+		 */
+		sil_rev = readl(cdev->deviceid) >> 28;
+		mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, dpll_mpu.m);
+
+		/* Tell the TPS65910 to use i2c */
+		tps65910_set_i2c_control();
+
+		/* First update MPU voltage. */
+		if (tps65910_voltage_update(MPU, mpu_vdd))
+		{
+		//	printf("$$$ update MPU voltage error\n");
+			return;
+		}
+
+		/* Second, update the CORE voltage. */
+		if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+		{
+		//	printf("$$$ update core voltage error \n");
+			return;
+		}
+
+                // Second, update the CORE voltage.
+                if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+                        return;
+}
+#endif
+
+/*
+ * early system init of muxing and clocks.
+ */
+void s_init(void)
+{
+	__maybe_unused struct am335x_baseboard_id header;
+#ifdef CONFIG_NOR_BOOT
+	asm("stmfd	sp!, {r2 - r4}");
+	asm("movw	r4, #0x8A4");
+	asm("movw	r3, #0x44E1");
+	asm("orr	r4, r4, r3, lsl #16");
+	asm("mov	r2, #9");
+	asm("mov	r3, #8");
+	asm("gpmc_mux:	str	r2, [r4], #4");
+	asm("subs	r3, r3, #1");
+	asm("bne	gpmc_mux");
+	asm("ldmfd	sp!, {r2 - r4}");
+#endif
+
+	/* WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	writel(0xAAAA, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+	writel(0x5555, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+	/* Setup the PLLs and the clocks for the peripherals */
+	pll_init();
+
+	/* Enable RTC32K clock */
+	rtc32k_enable();
+
+	/* UART softreset */
+	u32 regVal;
+
+#ifdef CONFIG_SERIAL1
+	enable_uart0_pin_mux();
+#endif /* CONFIG_SERIAL1 */
+#ifdef CONFIG_SERIAL2
+	enable_uart1_pin_mux();
+#endif /* CONFIG_SERIAL2 */
+#ifdef CONFIG_SERIAL3
+	enable_uart2_pin_mux();
+#endif /* CONFIG_SERIAL3 */
+#ifdef CONFIG_SERIAL4
+	enable_uart3_pin_mux();
+#endif /* CONFIG_SERIAL4 */
+#ifdef CONFIG_SERIAL5
+	enable_uart4_pin_mux();
+#endif /* CONFIG_SERIAL5 */
+#ifdef CONFIG_SERIAL6
+	enable_uart5_pin_mux();
+#endif /* CONFIG_SERIAL6 */
+
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_RESET;
+	writel(regVal, &uart_base->uartsyscfg);
+	while ((readl(&uart_base->uartsyssts) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK)
+		;
+
+	/* Disable smart idle */
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_SMART_IDLE_EN;
+	writel(regVal, &uart_base->uartsyscfg);
+
+#if defined(CONFIG_NOR_BOOT)
+	/* NOR booting - enable serial console */
+	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+	gd->baudrate = CONFIG_BAUDRATE;
+	serial_init();
+	gd->have_console = 1;
+#else
+	gd = &gdata;
+
+	preloader_console_init();
+#endif
+	
+//#ifdef CONFIG_AM335X_HTOUCH
+	printf("Using Dcim Board Configuration\n");
+//#endif
+
+	/* Enable board pin mux */
+	enable_board_pin_mux(&header);
+	
+	/* Use gpio0_7 for DDR3 VTT enable */
+	gpio_request(GPIO_DDR_VTT_EN, "ddr_vtt_en");
+	gpio_direction_output(GPIO_DDR_VTT_EN, 1);
+	
+	/* Initialze I2C1 (bus 2) */
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	//printf("calling am33xx_spl_board_init\n");
+	am33xx_spl_board_init();
+	//printf("$$$$$$$$$$called am33xx_spl_board_init*************\n");
+
+#ifdef CONFIG_NOR_BOOT
+	am33xx_spl_board_init();
+#endif
+
+	config_ddr(303, MT41J512M8RH125_IOCTRL_VALUE, &ddr3_data,
+			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data);
+#endif
+}
+
+#if defined(CONFIG_OMAP_HSMMC) && !defined(CONFIG_SPL_BUILD)
+int board_mmc_init(bd_t *bis)
+{
+	return omap_mmc_init(0, 0, 0);
+}
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	gd->bd->bi_boot_params = PHYS_DRAM_1 + 0x100;
+
+	gpmc_init();
+
+	return 0;
+}
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+
+/* TODO : Check for the board specific PHY */
+static void phy_init1(char *name, int addr)
+{
+	unsigned short val;
+	//const char *devname;
+	name = miiphy_get_current_dev();
+
+	 printf("Configuring Marvell Phy\n\n");
+	 /* This disables internally transmit clock delay */
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE_ADDRESS, 2); /* select page 2 */
+	 miiphy_read(name, 0x0, MARVELL_MII_PAGE2_MAC_CONTROL, &val);
+	 val &= ~0x10; /* RGMII Transmit Timing Control */
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE2_MAC_CONTROL, val);
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE_ADDRESS, 0); /* back to page 0 */
+	 /* Changes to MAC CONTROL register must be followed by software reset to take effekt */
+	 miiphy_reset(name, 0x0);
+
+	return;
+}
+
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_id		= 0,
+		.phy_if		= PHY_INTERFACE_MODE_RMII,    
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_id		= 1,
+		.phy_if		= PHY_INTERFACE_MODE_RGMII,    
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= AM335X_CPSW_MDIO_BASE,
+	.cpsw_base		= AM335X_CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	//.phy_init1               = phy_init1,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if defined(CONFIG_DRIVER_TI_CPSW) || \
+	(defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET))
+
+
+
+int board_eth_init(bd_t *bis)
+{	
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+
+	// try reading mac address from efuse 
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ether_addr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+///new code added ///
+/*#ifdef CONFIG_DRIVER_TI_CPSW
+ 
+         mac_lo = readl(&cdev->macid1l);
+         mac_hi = readl(&cdev->macid1h);
+         mac_addr[0] = mac_hi & 0xFF;
+         mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+         mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+         mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+         mac_addr[4] = mac_lo & 0xFF;
+         mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	printf("setting mac here \n");
+	if (!getenv("eth1addr")) {
+                if (is_valid_ether_addr(mac_addr))
+                         eth_setenv_enetaddr("eth1addr", mac_addr);
+         }
+
+*/
+///////////////////end code ///////////////
+
+	writel(RMII_MODE_ENABLE , &cdev->miisel);
+	cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RMII;
+	writel(RGMII_MODE_ENABLE , &cdev->miisel);
+	cpsw_slaves[1].phy_if =	PHY_INTERFACE_MODE_RGMII;
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+
+
+
+//#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USB_ETH_SUPPORT))
+	if (is_valid_ether_addr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+	
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
+
+/* configure eth0 PHY board-specific LED behavior */
+int board_phy_config(struct phy_device *phydev)
+{
+	unsigned short val;
+	/* Marvel 88E1510 */
+	if (phydev->phy_id == 0x1410dd1) {
+		/*
+		 * Page 3, Register 16: LED[2:0] Function Control Register
+		 * LED[0] (SPD:Amber) R16_3.3:0 to 0111: on-GbE link
+		 * LED[1] (LNK:Green) R16_3.7:4 to 0001: on-link, blink-activity
+		 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 3);
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 16);
+		val &= 0xff00;
+		val |= 0x0017;
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, val);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#endif
diff --git a/board/cti/dcim/board.h b/board/cti/dcim/board.h
new file mode 100644
index 0000000..48e112e
--- /dev/null
+++ b/board/cti/dcim/board.h
@@ -0,0 +1,54 @@
+/*
+ * board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/*
+ * TI AM335x parts define a system EEPROM that defines certain sub-fields.
+ * We use these fields to in turn see what board we are on, and what
+ * that might require us to set or not set.
+ */
+#define HDR_NO_OF_MAC_ADDR	3
+#define HDR_ETH_ALEN		6
+#define HDR_NAME_LEN		8
+
+struct am335x_baseboard_id {
+	unsigned int  magic;
+	char name[HDR_NAME_LEN];
+	char version[4];
+	char serial[12];
+	char config[32];
+	char mac_addr[HDR_NO_OF_MAC_ADDR][HDR_ETH_ALEN];
+};
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(struct am335x_baseboard_id *header);
+#endif
diff --git a/board/cti/dcim/mux.c b/board/cti/dcim/mux.c
new file mode 100644
index 0000000..550977c
--- /dev/null
+++ b/board/cti/dcim/mux.c
@@ -0,0 +1,601 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <i2c.h>
+
+#define MUX_CFG(value, offset)	\
+	__raw_writel(value, (CTRL_BASE + offset));
+
+/* PAD Control Fields */
+
+#define RXACTIVE	(0x1 << 5)
+#define PULLUP_EN	(0x1 << 4) /* internal Pull UP enabled */
+#define PULLUDEN	(0x0 << 3) /* internal Pull dwn enabled */
+#define PULLUDDIS	(0x1 << 3) /* internal Pull disabled */
+#define MODE(val)	val	/* used for Readability */
+//I PU
+//O PD
+/*
+ * PAD CONTROL OFFSETS
+ * Field names corresponds to the pad signal name
+ */
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;
+	int gpmc_a5;
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;
+	int gpmc_a11;
+	int gpmc_wait0;
+	int gpmc_wpn;
+	int gpmc_be1n;
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;
+	int mii1_crs;
+	int mii1_rxerr;
+	int mii1_txen;
+	int mii1_rxdv;
+	int mii1_txd3;
+	int mii1_txd2;
+	int mii1_txd1;
+	int mii1_txd0;
+	int mii1_txclk;
+	int mii1_rxclk;
+	int mii1_rxd3;
+	int mii1_rxd2;
+	int mii1_rxd1;
+	int mii1_rxd0;
+	int rmii1_refclk;
+	int mdio_data;
+	int mdio_clk;
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+struct module_pin_mux {
+	short reg_offset;
+	unsigned char val;
+};
+
+/* Pad control register offset */
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *) \
+				(PAD_CTRL_BASE))->x)
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc2_pin_mux[] = {
+	{OFFSET(gpmc_be1n),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* U18 - MMC2_DAT3 */
+	{OFFSET(gpmc_a3),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* T14 - MMC2_DAT2 */
+	{OFFSET(gpmc_a2),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* U14 - MMC2_DAT1 */
+	{OFFSET(gpmc_a1),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* V14 - MMC2_DAT0 */
+	{OFFSET(gpmc_clk),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* V12 - MMC2_CLK */
+	{OFFSET(gpmc_csn3),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* T13 - MMC2_CMD */
+	{OFFSET(gpmc_wpn),	(MODE(4) | RXACTIVE | PULLUP_EN)},	/* U17 - MMC2_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDDIS)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDDIS)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(uart0_ctsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_DATA */
+	{OFFSET(uart0_rtsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS )},	/* I2C_SCLK */
+	{-1},
+};
+
+//SLEWCTRL
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+
+static struct module_pin_mux rgmii2_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(2)},				/* RGMII1_TCTL */
+	{OFFSET(gpmc_a1), MODE(2) | RXACTIVE},			/* RGMII1_RCTL */
+	{OFFSET(gpmc_a2), MODE(2)},				/* RGMII1_TD3 */
+	{OFFSET(gpmc_a3), MODE(2)},				/* RGMII1_TD2 */
+	{OFFSET(gpmc_a4), MODE(2)},				/* RGMII1_TD1 */
+	{OFFSET(gpmc_a5), MODE(2)},				/* RGMII1_TD0 */
+	{OFFSET(gpmc_a6), MODE(2)},				/* RGMII1_TCLK */
+	{OFFSET(gpmc_a7), MODE(2) | RXACTIVE},			/* RGMII1_RCLK */
+	{OFFSET(gpmc_a8), MODE(2) | RXACTIVE},			/* RGMII1_RD3 */
+	{OFFSET(gpmc_a9), MODE(2) | RXACTIVE},			/* RGMII1_RD2 */
+	{OFFSET(gpmc_a10), MODE(2) | RXACTIVE},			/* RGMII1_RD1 */
+	{OFFSET(gpmc_a11), MODE(2) | RXACTIVE},			/* RGMII1_RD0 */
+	{OFFSET(mcasp0_aclkr), MODE(7) | PULLUDEN},    		/*RESET*/
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mii1_col), MODE(7) | PULLUP_EN},        	/* LED2/INTn */
+	{-1},
+};
+
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},		/* RMII1_RXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},		/* RMII1_RXD1 */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},		/* RMII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},				/* RMII1_TXEN */
+	{OFFSET(mii1_txd0), MODE(1)},				/* RMII1_TXD0 */
+	{OFFSET(mii1_txd1), MODE(1)},				/* RMII1_TXD1 */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* RMII1_CRS_DV */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},		/* RMII1_REFCLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},		/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_csn1), (MODE(2) |  RXACTIVE | PULLUP_EN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* NAND_CS0 */
+
+	{OFFSET(spi0_d0), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+
+	{-1},
+};
+
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A7 */
+	{OFFSET(lcd_vsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A8 */
+	{OFFSET(lcd_hsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A9 */
+	{OFFSET(lcd_pclk), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A10 */
+	{OFFSET(lcd_ac_bias_en), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A19 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD15 */
+
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN) | RXACTIVE},	/* NOR_CE */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN) | RXACTIVE}, /* NOR_ADVN_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_OE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_BE0N_CLE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN | RXACTIVE)},	/* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUDEN)}, /* NOR WAIT */
+	{-1},
+};
+#endif
+
+/*
+static struct module_pin_mux gpio3_7_pin_mux[] = {
+	{OFFSET(emu0), MODE(7) | PULLUDDIS | RXACTIVE},	// gpio3_7 - used for WLAN IRQ
+	{-1},
+};*/
+
+
+static struct module_pin_mux gpios_pin_mux[] = {
+	{OFFSET(gpmc_be1n), MODE(7) | PULLUDEN | RXACTIVE},	// gpio1_28 - HeartBeat LED in Sink mode
+	{OFFSET(gpmc_clk), MODE(7) | PULLUDEN | RXACTIVE},	// gpio2_1 - Ethernet switch reset signal
+	{OFFSET(gpmc_csn3), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio2_0 - HDMI Transmitter INT signal
+	{OFFSET(mcasp0_aclkr), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_18 - Gigabit PHY reset signal
+	{OFFSET(mcasp0_ahclkx), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_21 - USB HUB reset signal
+	{OFFSET(mcasp0_fsr), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_19 - GPIO to set the PMIC in SLEEP state
+	{OFFSET(mcasp0_axr1), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio3_20 - Ethernet switch interrupt signal
+	{OFFSET(mii1_col), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio3_0 - Gigabit PHY interrupt signal
+	{OFFSET(mii1_txd2), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_17 - MCU reset signal
+	{OFFSET(mii1_txd3), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio0_16 - INT signal from PMIC
+	{OFFSET(spi0_cs0), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_5 - Shutdown status signal to MCU at the time of shutdown
+	{OFFSET(spi0_cs1), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio0_6 - INT signal from Power switch IC - LTC2955C to shutdown the system
+	{OFFSET(spi0_d0), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_3 - eMMC  (MMC1) reset signal
+	{-1},
+};
+
+/*
+ * Configure the pin mux for the module
+ */
+static void configure_module_pin_mux(struct module_pin_mux *mod_pin_mux)
+{
+	int i;
+
+	if (!mod_pin_mux)
+		return;
+
+	for (i = 0; mod_pin_mux[i].reg_offset != -1; i++)
+		MUX_CFG(mod_pin_mux[i].val, mod_pin_mux[i].reg_offset);
+}
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+
+void enable_board_pin_mux(struct am335x_baseboard_id *header)
+{
+#ifdef CONFIG_AM335X_DCIM
+	/* DCIM */
+	printf("Using DCIM Pin Mux\n");
+	//configure_module_pin_mux(gpio0_7_pin_mux);
+	configure_module_pin_mux(gpios_pin_mux);
+	configure_module_pin_mux(i2c1_pin_mux);
+	configure_module_pin_mux(i2c2_pin_mux);
+	configure_module_pin_mux(nand_pin_mux);
+	configure_module_pin_mux(rgmii2_pin_mux);
+	configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	configure_module_pin_mux(mmc2_pin_mux);
+#else
+	/* Do board-specific muxes. */
+	if (!strncmp(header->name, "A335BONE", HDR_NAME_LEN)) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#endif
+	} else if (!strncmp(header->config, "SKU#01", 6)) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii2_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (!strncmp(header->name, "A335X_SK", HDR_NAME_LEN)) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii2_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else {
+		puts("Unknown board, cannot configure pinmux.");
+		hang();
+	}
+#endif
+}
diff --git a/board/cti/dcim/pmic.h b/board/cti/dcim/pmic.h
new file mode 100644
index 0000000..b9851e8
--- /dev/null
+++ b/board/cti/dcim/pmic.h
@@ -0,0 +1,77 @@
+/*
+ * pmic.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef PMIC_h
+#define PMIC_H
+
+/*
+ * The PMIC on this board is a TPS65910.
+ */
+
+#define PMIC_SR_I2C_ADDR		0x12
+#define PMIC_CTRL_I2C_ADDR		0x2D
+/* PMIC Register offsets */
+#define PMIC_VDD1_REG			0x21
+#define PMIC_VDD1_OP_REG		0x22
+#define PMIC_VDD2_REG			0x24
+#define PMIC_VDD2_OP_REG		0x25
+#define PMIC_DEVCTRL_REG		0x3f
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define PMIC_VGAIN_SEL_MASK		(0x3 << 6)
+#define PMIC_ILMAX_MASK			(0x1 << 5)
+#define PMIC_TSTEP_MASK			(0x7 << 2)
+#define PMIC_ST_MASK			(0x3)
+
+#define PMIC_REG_VGAIN_SEL_X1		(0x0 << 6)
+#define PMIC_REG_VGAIN_SEL_X1_0		(0x1 << 6)
+#define PMIC_REG_VGAIN_SEL_X3		(0x2 << 6)
+#define PMIC_REG_VGAIN_SEL_X4		(0x3 << 6)
+
+#define PMIC_REG_ILMAX_1_0_A		(0x0 << 5)
+#define PMIC_REG_ILMAX_1_5_A		(0x1 << 5)
+
+#define PMIC_REG_TSTEP_			(0x0 << 2)
+#define PMIC_REG_TSTEP_12_5		(0x1 << 2)
+#define PMIC_REG_TSTEP_9_4		(0x2 << 2)
+#define PMIC_REG_TSTEP_7_5		(0x3 << 2)
+#define PMIC_REG_TSTEP_6_25		(0x4 << 2)
+#define PMIC_REG_TSTEP_4_7		(0x5 << 2)
+#define PMIC_REG_TSTEP_3_12		(0x6 << 2)
+#define PMIC_REG_TSTEP_2_5		(0x7 << 2)
+
+#define PMIC_REG_ST_OFF			(0x0)
+#define PMIC_REG_ST_ON_HI_POW		(0x1)
+#define PMIC_REG_ST_OFF_1		(0x2)
+#define PMIC_REG_ST_ON_LOW_POW		(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define PMIC_OP_REG_SEL				(0x7F)
+
+#define PMIC_OP_REG_CMD_MASK			(0x1 << 7)
+#define PMIC_OP_REG_CMD_OP			(0x0 << 7)
+#define PMIC_OP_REG_CMD_SR			(0x1 << 7)
+
+#define PMIC_OP_REG_SEL_MASK			(0x7F)
+#define PMIC_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define PMIC_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define PMIC_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_MASK	(0x1 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+#endif
diff --git a/board/cti/dcim/tps65217.h b/board/cti/dcim/tps65217.h
new file mode 100644
index 0000000..8f2309a
--- /dev/null
+++ b/board/cti/dcim/tps65217.h
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2011
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __TPS65217_H__
+#define __TPS65217_H__
+
+#include <common.h>
+#include <i2c.h>
+
+/* I2C chip address */
+#define TPS65217_CHIP_PM		0x24
+
+/* Registers */
+#define CHIPID				0x00
+#define POWER_PATH			0x01
+#define INTERRUPT			0x02
+#define CHGCONFIG0			0x03
+#define CHGCONFIG1			0x04
+#define CHGCONFIG2			0x05
+#define CHGCONFIG3			0x06
+#define WLEDCTRL1			0x07
+#define WLEDCTRL2			0x08
+#define MUXCTRL				0x09
+#define STATUS				0x0A
+#define PASSWORD			0x0B
+#define PGOOD				0x0C
+#define DEFPG				0x0D
+#define DEFDCDC1			0x0E
+#define DEFDCDC2			0x0F
+#define DEFDCDC3			0x10
+#define DEFSLEW				0x11
+#define DEFLDO1				0x12
+#define DEFLDO2				0x13
+#define DEFLS1				0x14
+#define DEFLS2				0x15
+#define ENABLE				0x16
+#define DEFUVLO				0x18
+#define SEQ1				0x19
+#define SEQ2				0x1A
+#define SEQ3				0x1B
+#define SEQ4				0x1C
+#define SEQ5				0x1D
+#define SEQ6				0x1E
+
+#define PROT_LEVEL_NONE			0x00
+#define PROT_LEVEL_1			0x01
+#define PROT_LEVEL_2			0x02
+
+#define PASSWORD_LOCK_FOR_WRITE		0x00
+#define PASSWORD_UNLOCK			0x7D
+
+#define DCDC_GO				0x80
+
+#define MASK_ALL_BITS			0xFF
+
+#define USB_INPUT_CUR_LIMIT_MASK	0x03
+#define USB_INPUT_CUR_LIMIT_100MA	0x00
+#define USB_INPUT_CUR_LIMIT_500MA	0x01
+#define USB_INPUT_CUR_LIMIT_1300MA	0x02
+#define USB_INPUT_CUR_LIMIT_1800MA	0x03
+
+#define DCDC_VOLT_SEL_1125MV		0x09
+#define DCDC_VOLT_SEL_1275MV		0x0F
+#define DCDC_VOLT_SEL_1325MV		0x11
+
+#define LDO_MASK			0x1F
+#define LDO_VOLTAGE_OUT_1_8		0x06
+#define LDO_VOLTAGE_OUT_3_3		0x1F
+
+#define PWR_SRC_USB_BITMASK		0x4
+#define PWR_SRC_AC_BITMASK		0x8
+#endif
diff --git a/board/cti/dcim/tps65910.h b/board/cti/dcim/tps65910.h
new file mode 100644
index 0000000..f5fe744
--- /dev/null
+++ b/board/cti/dcim/tps65910.h
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2011-2013
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ *
+ * For more details, please see the TRM at http://www.ti.com/product/tps65910
+ */
+#ifndef __POWER_TPS65910_H__
+#define __POWER_TPS65910_H__
+
+#define MPU     0
+#define CORE    1
+
+#define TPS65910_SR_I2C_ADDR				0x12
+#define TPS65910_CTRL_I2C_ADDR				0x2D
+
+/* PMIC Register offsets */
+#define TPS65910_VDD1_REG				0x21
+#define TPS65910_VDD1_OP_REG				0x22
+#define TPS65910_VDD2_REG				0x24
+#define TPS65910_VDD2_OP_REG				0x25
+#define TPS65910_DEVCTRL_REG				0x3F
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define TPS65910_VGAIN_SEL_MASK				(0x3 << 6)
+#define TPS65910_ILMAX_MASK				(0x1 << 5)
+#define TPS65910_TSTEP_MASK				(0x7 << 2)
+#define TPS65910_ST_MASK				(0x3)
+
+#define TPS65910_REG_VGAIN_SEL_X1			(0x0 << 6)
+#define TPS65910_REG_VGAIN_SEL_X1_0			(0x1 << 6)
+#define TPS65910_REG_VGAIN_SEL_X3			(0x2 << 6)
+#define TPS65910_REG_VGAIN_SEL_X4			(0x3 << 6)
+
+#define TPS65910_REG_ILMAX_1_0_A			(0x0 << 5)
+#define TPS65910_REG_ILMAX_1_5_A			(0x1 << 5)
+
+#define TPS65910_REG_TSTEP_				(0x0 << 2)
+#define TPS65910_REG_TSTEP_12_5				(0x1 << 2)
+#define TPS65910_REG_TSTEP_9_4				(0x2 << 2)
+#define TPS65910_REG_TSTEP_7_5				(0x3 << 2)
+#define TPS65910_REG_TSTEP_6_25				(0x4 << 2)
+#define TPS65910_REG_TSTEP_4_7				(0x5 << 2)
+#define TPS65910_REG_TSTEP_3_12				(0x6 << 2)
+#define TPS65910_REG_TSTEP_2_5				(0x7 << 2)
+
+#define TPS65910_REG_ST_OFF				(0x0)
+#define TPS65910_REG_ST_ON_HI_POW			(0x1)
+#define TPS65910_REG_ST_OFF_1				(0x2)
+#define TPS65910_REG_ST_ON_LOW_POW			(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define TPS65910_OP_REG_SEL				(0x7F)
+
+#define TPS65910_OP_REG_CMD_MASK			(0x1 << 7)
+#define TPS65910_OP_REG_CMD_OP				(0x0 << 7)
+#define TPS65910_OP_REG_CMD_SR				(0x1 << 7)
+
+#define TPS65910_OP_REG_SEL_MASK			(0x7F)
+#define TPS65910_OP_REG_SEL_0_9_5			(0x1F)	/* 0.9500 V */
+#define TPS65910_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define TPS65910_OP_REG_SEL_1_2_0			(0x33)	/* 1.2000 V */
+#define TPS65910_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define TPS65910_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_MASK		(0x1 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+int tps65910_set_i2c_control(void);
+int tps65910_voltage_update(unsigned int module, unsigned char vddx_op_vol_sel);
+#endif	
+/* __POWER_TPS65910_H__ */
diff --git a/board/cti/dcim/u-boot.lds b/board/cti/dcim/u-boot.lds
new file mode 100644
index 0000000..2766ec8
--- /dev/null
+++ b/board/cti/dcim/u-boot.lds
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		__image_copy_start = .;
+		CPUDIR/start.o (.text*)
+		board/cti/dcim/libdcim.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+	#include <u-boot.lst>
+	}
+
+	. = ALIGN(4);
+
+	__image_copy_end = .;
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss*)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
+
+#if defined(CONFIG_SPL_TEXT_BASE) && defined(CONFIG_SPL_MAX_SIZE)
+ASSERT(__bss_end__ < (CONFIG_SPL_TEXT_BASE + CONFIG_SPL_MAX_SIZE), "SPL image too big");
+#endif
diff --git a/board/hetronic/htouch/Makefile b/board/hetronic/htouch/Makefile
new file mode 100644
index 0000000..1795e3e
--- /dev/null
+++ b/board/hetronic/htouch/Makefile
@@ -0,0 +1,46 @@
+#
+# Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed "as is" WITHOUT ANY WARRANTY of any
+# kind, whether express or implied; without even the implied warranty
+# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+ifeq ($(CONFIG_SPL_BUILD)$(CONFIG_NOR_BOOT),y)
+COBJS	:= mux.o
+endif
+
+COBJS	+= board.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/hetronic/htouch/board.c b/board/hetronic/htouch/board.c
new file mode 100644
index 0000000..f950441
--- /dev/null
+++ b/board/hetronic/htouch/board.c
@@ -0,0 +1,627 @@
+/*
+ * board.c
+ *
+ * Common board functions for AM33XX based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/omap_common.h>
+#include <errno.h>
+#include <spl.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clocks_am33xx.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include "board.h"
+#include "pmic.h"
+#include "tps65910.h"
+#include <asm/arch/mem.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct wd_timer *wdtimer = (struct wd_timer *)WDT_BASE;
+struct uart_sys *uart_base = (struct uart_sys *)DEFAULT_UART_BASE;
+
+/* MAIN PLL Fdll = 550 MHz, by default */
+#ifndef CONFIG_SYS_MPUCLK
+#define CONFIG_SYS_MPUCLK       MPUPLL_M_550
+#endif
+
+#define PHY_CONF_REG 22
+#define PHY_CONF_TXCLKEN (1 << 5)
+#define MARVELL_88E15xx 0x1410dd1
+#define MARVELL_MII_PAGE2_MAC_CONTROL 21
+#define MARVELL_MII_PAGE_ADDRESS 22
+
+/* MII mode defines */
+/* b7 - RMII2 clock source: 0 = from PLL, 1 = from chip pin
+ * b6 - RMII1 clock source: 0 = from PLL, 1 = from chip pin
+ * b5 - RGMII2 Internal Delay Mode: 0 = Internal Delay, 1 = No Internal Delay
+ * b4 - RGMII1 Internal Delay Mode: 0 = Internal Delay, 1 = No Internal Delay
+ * b3:2 - Port 2 Mode Select: 00 = GMII/MII, 01 = RMII Mode, 10 = RGMII Mode, 11 = Not Used
+ * b1:0 - Port 1 Mode Select: 00 = GMII/MII, 01 = RMII Mode, 10 = RGMII Mode, 11 = Not Used
+ */
+//#define MII_MODE_ENABLE		0x00
+#define RMII_MODE_ENABLE	0xFD
+#define RGMII_MODE_ENABLE	0xF9
+//0X3A
+
+/* GPIO that controls power to DDR3 VTT */
+#define GPIO_DDR_VTT_EN		7
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+static struct am335x_baseboard_id __attribute__((section (".data"))) header;
+
+/* Needed for EMIF4 module */
+int board_is_evm_15_or_later(void)
+{
+	return 0;
+}
+
+/*
+ * Read header information from EEPROM into global structure.
+ */
+static int read_eeprom(struct am335x_baseboard_id *header)
+{
+	/* Check if baseboard eeprom is available */
+	if (i2c_probe(CONFIG_SYS_I2C_EEPROM_ADDR)) {
+		puts("Could not probe the EEPROM; something fundamentally "
+			"wrong on the I2C bus.\n");
+		return -ENODEV;
+	}
+
+	/* read the eeprom using i2c */
+	if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 2, (uchar *)header,
+		     sizeof(struct am335x_baseboard_id))) {
+		puts("Could not read the EEPROM; something fundamentally"
+			" wrong on the I2C bus.\n");
+		return -EIO;
+	}
+
+	if (header->magic != 0xEE3355AA) {
+		/*
+		 * read the eeprom using i2c again,
+		 * but use only a 1 byte address
+		 */
+		if (i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, 1, (uchar *)header,
+			     sizeof(struct am335x_baseboard_id))) {
+			puts("Could not read the EEPROM; something "
+				"fundamentally wrong on the I2C bus.\n");
+			return -EIO;
+		}
+
+		if (header->magic != 0xEE3355AA) {
+			printf("Incorrect magic number (0x%x) in EEPROM\n",
+					header->magic);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+
+/*
+ * tps65910_set_i2c_control() - Set the TPS65910 to be controlled via the I2C
+ * 				interface.
+ * @return:		       0 on success, not 0 on failure
+ */
+int tps65910_set_i2c_control(void)
+{
+	int ret;
+	uchar buf;
+
+	/* VDD1/2 voltage selection register access by control i/f */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, TPS65910_DEVCTRL_REG, 1,
+		       &buf, 1);
+
+	if (ret)
+		return ret;
+
+	buf |= TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C;
+
+	return i2c_write(TPS65910_CTRL_I2C_ADDR, TPS65910_DEVCTRL_REG, 1,
+			 &buf, 1);
+}
+
+/*
+ * tps65910_voltage_update() - Voltage switching for MPU frequency switching.
+ * @module:		       mpu - 0, core - 1
+ * @vddx_op_vol_sel:	       vdd voltage to set
+ * @return:		       0 on success, not 0 on failure
+ */
+int tps65910_voltage_update(unsigned int module, unsigned char vddx_op_vol_sel)
+{
+	uchar buf;
+	unsigned int reg_offset;
+	int ret;
+
+	if (module == MPU)
+		reg_offset = TPS65910_VDD1_OP_REG;
+	else
+		reg_offset = TPS65910_VDD2_OP_REG;
+
+	/* Select VDDx OP   */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	buf &= ~TPS65910_OP_REG_CMD_MASK;
+
+	ret = i2c_write(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	/* Configure VDDx OP  Voltage */
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	buf &= ~TPS65910_OP_REG_SEL_MASK;
+	buf |= vddx_op_vol_sel;
+
+	ret = i2c_write(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	ret = i2c_read(TPS65910_CTRL_I2C_ADDR, reg_offset, 1, &buf, 1);
+	if (ret)
+		return ret;
+
+	if ((buf & TPS65910_OP_REG_SEL_MASK) != vddx_op_vol_sel)
+		return 1;
+
+	return 0;
+}
+
+
+
+/* UART Defines */
+#define UART_RESET		(0x1 << 1)
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+static void rtc32k_enable(void)
+{
+	struct rtc_regs *rtc = (struct rtc_regs *)AM335X_RTC_BASE;
+
+	/*
+	 * Unlock the RTC's registers.  For more details please see the
+	 * RTC_SS section of the TRM.  In order to unlock we need to
+	 * write these specific values (keys) in this order.
+	 */
+	writel(0x83e70b13, &rtc->kick0r);
+	writel(0x95a4f1e0, &rtc->kick1r);
+
+	/* Enable the RTC 32K OSC by setting bits 3 and 6. */
+	writel((1 << 3) | (1 << 6), &rtc->osc);
+}
+
+
+static const struct ddr_data ddr3_data = {
+	.datardsratio0 = MT41J512M8RH125_RD_DQS,
+	.datawdsratio0 = MT41J512M8RH125_WR_DQS,
+	.datafwsratio0 = MT41J512M8RH125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J512M8RH125_PHY_WR_DATA,
+	.datadldiff0 = PHY_DLL_LOCK_DIFF,
+};
+static const struct cmd_control ddr3_evm_cmd_ctrl_data = {
+	.cmd0csratio = MT41J512M8RH125_RATIO,
+	.cmd0dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd0iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J512M8RH125_RATIO,
+	.cmd1dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd1iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J512M8RH125_RATIO,
+	.cmd2dldiff = MT41J512M8RH125_DLL_LOCK_DIFF,
+	.cmd2iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+};
+
+
+
+static struct emif_regs ddr3_evm_emif_reg_data = {
+	.sdram_config = MT41J512M8RH125_EMIF_SDCFG,
+	.ref_ctrl = MT41J512M8RH125_EMIF_SDREF,
+	.sdram_tim1 = MT41J512M8RH125_EMIF_TIM1,
+	.sdram_tim2 = MT41J512M8RH125_EMIF_TIM2,
+	.sdram_tim3 = MT41J512M8RH125_EMIF_TIM3,
+	.zq_config = MT41J512M8RH125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J512M8RH125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	/* break into full u-boot on 'c' */
+	return (serial_tstc() && (serial_getc() == 'c'));
+}
+#endif
+
+const struct dpll_regs dpll_mpu_regs = {
+.cm_clkmode_dpll	= CM_WKUP + 0x88,
+.cm_idlest_dpll	= CM_WKUP + 0x20,
+.cm_clksel_dpll	= CM_WKUP + 0x2C,
+.cm_div_m2_dpll	= CM_WKUP + 0xA8,
+};
+
+void am33xx_spl_board_init(void)
+{
+	struct am335x_baseboard_id header;
+	struct dpll_params dpll_mpu = {0, OSC-1, 1, -1, -1, -1, -1, 0, 0, 0, 0, 0};
+	int mpu_vdd, mpu_pll, sil_rev;
+
+	/* Assume PG 1.0 */
+	mpu_pll = MPUPLL_M_720;
+
+
+		/*
+		 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+		 * MPU frequencies we support we use a CORE voltage of
+		 * 1.1375V.  For MPU voltage we need to switch based on
+		 * the frequency we are running at.
+		 */
+
+		if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		{
+			//printf("$$$ i2c probe returned with error \n");
+			return;
+		}
+
+		/*
+		 * Depending on MPU clock and PG we will need a different
+		 * VDD to drive at that speed.
+		 */
+		sil_rev = readl(cdev->deviceid) >> 28;
+		mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, dpll_mpu.m);
+
+		/* Tell the TPS65910 to use i2c */
+		tps65910_set_i2c_control();
+
+		/* First update MPU voltage. */
+		if (tps65910_voltage_update(MPU, mpu_vdd))
+		{
+			printf("$$$ update MPU voltage error\n");
+			return;
+		}
+
+		/* Second, update the CORE voltage. */
+		if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+		{
+			printf("$$$ update core voltage error \n");
+			return;
+		}
+
+                // Second, update the CORE voltage.
+                if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+                        return;
+}
+#endif
+
+/*
+ * early system init of muxing and clocks.
+ */
+void s_init(void)
+{
+	__maybe_unused struct am335x_baseboard_id header;
+#ifdef CONFIG_NOR_BOOT
+	asm("stmfd	sp!, {r2 - r4}");
+	asm("movw	r4, #0x8A4");
+	asm("movw	r3, #0x44E1");
+	asm("orr	r4, r4, r3, lsl #16");
+	asm("mov	r2, #9");
+	asm("mov	r3, #8");
+	asm("gpmc_mux:	str	r2, [r4], #4");
+	asm("subs	r3, r3, #1");
+	asm("bne	gpmc_mux");
+	asm("ldmfd	sp!, {r2 - r4}");
+#endif
+
+	/* WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	writel(0xAAAA, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+	writel(0x5555, &wdtimer->wdtwspr);
+	while (readl(&wdtimer->wdtwwps) != 0x0)
+		;
+
+#if defined(CONFIG_SPL_BUILD) || defined(CONFIG_NOR_BOOT)
+	/* Setup the PLLs and the clocks for the peripherals */
+	pll_init();
+
+	/* Enable RTC32K clock */
+	rtc32k_enable();
+
+	/* UART softreset */
+	u32 regVal;
+
+#ifdef CONFIG_SERIAL1
+	enable_uart0_pin_mux();
+#endif /* CONFIG_SERIAL1 */
+#ifdef CONFIG_SERIAL2
+	enable_uart1_pin_mux();
+#endif /* CONFIG_SERIAL2 */
+#ifdef CONFIG_SERIAL3
+	enable_uart2_pin_mux();
+#endif /* CONFIG_SERIAL3 */
+#ifdef CONFIG_SERIAL4
+	enable_uart3_pin_mux();
+#endif /* CONFIG_SERIAL4 */
+#ifdef CONFIG_SERIAL5
+	enable_uart4_pin_mux();
+#endif /* CONFIG_SERIAL5 */
+#ifdef CONFIG_SERIAL6
+	enable_uart5_pin_mux();
+#endif /* CONFIG_SERIAL6 */
+
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_RESET;
+	writel(regVal, &uart_base->uartsyscfg);
+	while ((readl(&uart_base->uartsyssts) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK)
+		;
+
+	/* Disable smart idle */
+	regVal = readl(&uart_base->uartsyscfg);
+	regVal |= UART_SMART_IDLE_EN;
+	writel(regVal, &uart_base->uartsyscfg);
+
+#if defined(CONFIG_NOR_BOOT)
+	/* NOR booting - enable serial console */
+	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+	gd->baudrate = CONFIG_BAUDRATE;
+	serial_init();
+	gd->have_console = 1;
+#else
+	gd = &gdata;
+
+	preloader_console_init();
+#endif
+	
+//#ifdef CONFIG_AM335X_HTOUCH
+	printf("Using Dcim Board Configuration\n");
+//#endif
+
+	/* Enable board pin mux */
+	enable_board_pin_mux(&header);
+	
+	/* Use gpio0_7 for DDR3 VTT enable */
+	gpio_request(GPIO_DDR_VTT_EN, "ddr_vtt_en");
+	gpio_direction_output(GPIO_DDR_VTT_EN, 1);
+	
+	/* Initialze I2C1 (bus 2) */
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	//printf("calling am33xx_spl_board_init\n");
+	am33xx_spl_board_init();
+	//printf("$$$$$$$$$$called am33xx_spl_board_init*************\n");
+
+#ifdef CONFIG_NOR_BOOT
+	am33xx_spl_board_init();
+#endif
+
+	config_ddr(303, MT41J512M8RH125_IOCTRL_VALUE, &ddr3_data,
+			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data);
+#endif
+}
+
+#if defined(CONFIG_OMAP_HSMMC) && !defined(CONFIG_SPL_BUILD)
+int board_mmc_init(bd_t *bis)
+{
+	return omap_mmc_init(0, 0, 0);
+}
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	gd->bd->bi_boot_params = PHYS_DRAM_1 + 0x100;
+
+	gpmc_init();
+
+	return 0;
+}
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+
+/* TODO : Check for the board specific PHY */
+static void phy_init1(char *name, int addr)
+{
+	unsigned short val;
+	//const char *devname;
+	name = miiphy_get_current_dev();
+
+	 printf("Configuring Marvell Phy\n\n");
+	 /* This disables internally transmit clock delay */
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE_ADDRESS, 2); /* select page 2 */
+	 miiphy_read(name, 0x0, MARVELL_MII_PAGE2_MAC_CONTROL, &val);
+	 val &= ~0x10; /* RGMII Transmit Timing Control */
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE2_MAC_CONTROL, val);
+	 miiphy_write(name, 0x0, MARVELL_MII_PAGE_ADDRESS, 0); /* back to page 0 */
+	 /* Changes to MAC CONTROL register must be followed by software reset to take effekt */
+	 miiphy_reset(name, 0x0);
+
+	return;
+}
+
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_id		= 0,
+		.phy_if		= PHY_INTERFACE_MODE_RMII,    
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_id		= 1,
+		.phy_if		= PHY_INTERFACE_MODE_RGMII,    
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= AM335X_CPSW_MDIO_BASE,
+	.cpsw_base		= AM335X_CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	//.phy_init1               = phy_init1,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if defined(CONFIG_DRIVER_TI_CPSW) || \
+	(defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET))
+
+
+
+int board_eth_init(bd_t *bis)
+{	
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+
+	// try reading mac address from efuse 
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ether_addr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+///new code added ///
+/*#ifdef CONFIG_DRIVER_TI_CPSW
+ 
+         mac_lo = readl(&cdev->macid1l);
+         mac_hi = readl(&cdev->macid1h);
+         mac_addr[0] = mac_hi & 0xFF;
+         mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+         mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+         mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+         mac_addr[4] = mac_lo & 0xFF;
+         mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	printf("setting mac here \n");
+	if (!getenv("eth1addr")) {
+                if (is_valid_ether_addr(mac_addr))
+                         eth_setenv_enetaddr("eth1addr", mac_addr);
+         }
+
+*/
+///////////////////end code ///////////////
+
+	writel(RMII_MODE_ENABLE , &cdev->miisel);
+	cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RMII;
+	writel(RGMII_MODE_ENABLE , &cdev->miisel);
+	cpsw_slaves[1].phy_if =	PHY_INTERFACE_MODE_RGMII;
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+
+
+
+//#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USB_ETH_SUPPORT))
+	if (is_valid_ether_addr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+	
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
+
+/* configure eth0 PHY board-specific LED behavior */
+int board_phy_config(struct phy_device *phydev)
+{
+	unsigned short val;
+	/* Marvel 88E1510 */
+	if (phydev->phy_id == 0x1410dd1) {
+		/*
+		 * Page 3, Register 16: LED[2:0] Function Control Register
+		 * LED[0] (SPD:Amber) R16_3.3:0 to 0111: on-GbE link
+		 * LED[1] (LNK:Green) R16_3.7:4 to 0001: on-link, blink-activity
+		 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 3);
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 16);
+		val &= 0xff00;
+		val |= 0x0017;
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, val);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#endif
diff --git a/board/hetronic/htouch/board.h b/board/hetronic/htouch/board.h
new file mode 100644
index 0000000..48e112e
--- /dev/null
+++ b/board/hetronic/htouch/board.h
@@ -0,0 +1,54 @@
+/*
+ * board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/*
+ * TI AM335x parts define a system EEPROM that defines certain sub-fields.
+ * We use these fields to in turn see what board we are on, and what
+ * that might require us to set or not set.
+ */
+#define HDR_NO_OF_MAC_ADDR	3
+#define HDR_ETH_ALEN		6
+#define HDR_NAME_LEN		8
+
+struct am335x_baseboard_id {
+	unsigned int  magic;
+	char name[HDR_NAME_LEN];
+	char version[4];
+	char serial[12];
+	char config[32];
+	char mac_addr[HDR_NO_OF_MAC_ADDR][HDR_ETH_ALEN];
+};
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(struct am335x_baseboard_id *header);
+#endif
diff --git a/board/hetronic/htouch/mux.c b/board/hetronic/htouch/mux.c
new file mode 100644
index 0000000..51ee398
--- /dev/null
+++ b/board/hetronic/htouch/mux.c
@@ -0,0 +1,601 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#include <i2c.h>
+
+#define MUX_CFG(value, offset)	\
+	__raw_writel(value, (CTRL_BASE + offset));
+
+/* PAD Control Fields */
+
+#define RXACTIVE	(0x1 << 5)
+#define PULLUP_EN	(0x1 << 4) /* internal Pull UP enabled */
+#define PULLUDEN	(0x0 << 3) /* internal Pull dwn enabled */
+#define PULLUDDIS	(0x1 << 3) /* internal Pull disabled */
+#define MODE(val)	val	/* used for Readability */
+//I PU
+//O PD
+/*
+ * PAD CONTROL OFFSETS
+ * Field names corresponds to the pad signal name
+ */
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;
+	int gpmc_a5;
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;
+	int gpmc_a11;
+	int gpmc_wait0;
+	int gpmc_wpn;
+	int gpmc_be1n;
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;
+	int mii1_crs;
+	int mii1_rxerr;
+	int mii1_txen;
+	int mii1_rxdv;
+	int mii1_txd3;
+	int mii1_txd2;
+	int mii1_txd1;
+	int mii1_txd0;
+	int mii1_txclk;
+	int mii1_rxclk;
+	int mii1_rxd3;
+	int mii1_rxd2;
+	int mii1_rxd1;
+	int mii1_rxd0;
+	int rmii1_refclk;
+	int mdio_data;
+	int mdio_clk;
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+struct module_pin_mux {
+	short reg_offset;
+	unsigned char val;
+};
+
+/* Pad control register offset */
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *) \
+				(PAD_CTRL_BASE))->x)
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc2_pin_mux[] = {
+	{OFFSET(gpmc_be1n),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* U18 - MMC2_DAT3 */
+	{OFFSET(gpmc_a3),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* T14 - MMC2_DAT2 */
+	{OFFSET(gpmc_a2),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* U14 - MMC2_DAT1 */
+	{OFFSET(gpmc_a1),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* V14 - MMC2_DAT0 */
+	{OFFSET(gpmc_clk),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* V12 - MMC2_CLK */
+	{OFFSET(gpmc_csn3),	(MODE(3) | RXACTIVE | PULLUP_EN)},	/* T13 - MMC2_CMD */
+	{OFFSET(gpmc_wpn),	(MODE(4) | RXACTIVE | PULLUP_EN)},	/* U17 - MMC2_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDDIS)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDDIS)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(uart0_ctsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_DATA */
+	{OFFSET(uart0_rtsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c2_pin_mux[] = {
+	{OFFSET(uart1_ctsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS)},	/* I2C_DATA */
+	{OFFSET(uart1_rtsn), (MODE(3) | RXACTIVE |
+			PULLUDDIS )},	/* I2C_SCLK */
+	{-1},
+};
+
+//SLEWCTRL
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+
+static struct module_pin_mux rgmii2_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(2)},				/* RGMII1_TCTL */
+	{OFFSET(gpmc_a1), MODE(2) | RXACTIVE},			/* RGMII1_RCTL */
+	{OFFSET(gpmc_a2), MODE(2)},				/* RGMII1_TD3 */
+	{OFFSET(gpmc_a3), MODE(2)},				/* RGMII1_TD2 */
+	{OFFSET(gpmc_a4), MODE(2)},				/* RGMII1_TD1 */
+	{OFFSET(gpmc_a5), MODE(2)},				/* RGMII1_TD0 */
+	{OFFSET(gpmc_a6), MODE(2)},				/* RGMII1_TCLK */
+	{OFFSET(gpmc_a7), MODE(2) | RXACTIVE},			/* RGMII1_RCLK */
+	{OFFSET(gpmc_a8), MODE(2) | RXACTIVE},			/* RGMII1_RD3 */
+	{OFFSET(gpmc_a9), MODE(2) | RXACTIVE},			/* RGMII1_RD2 */
+	{OFFSET(gpmc_a10), MODE(2) | RXACTIVE},			/* RGMII1_RD1 */
+	{OFFSET(gpmc_a11), MODE(2) | RXACTIVE},			/* RGMII1_RD0 */
+	{OFFSET(mcasp0_aclkr), MODE(7) | PULLUDEN},    		/*RESET*/
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mii1_col), MODE(7) | PULLUP_EN},        	/* LED2/INTn */
+	{-1},
+};
+
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},		/* RMII1_RXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},		/* RMII1_RXD1 */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},		/* RMII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},				/* RMII1_TXEN */
+	{OFFSET(mii1_txd0), MODE(1)},				/* RMII1_TXD0 */
+	{OFFSET(mii1_txd1), MODE(1)},				/* RMII1_TXD1 */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* RMII1_CRS_DV */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},		/* RMII1_REFCLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},		/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD0 */
+	{OFFSET(gpmc_ad1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD1 */
+	{OFFSET(gpmc_ad2), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD2 */
+	{OFFSET(gpmc_ad3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD3 */
+	{OFFSET(gpmc_ad4), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD4 */
+	{OFFSET(gpmc_ad5), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD5 */
+	{OFFSET(gpmc_ad6), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD6 */
+	{OFFSET(gpmc_ad7), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* NAND AD7 */
+	{OFFSET(gpmc_csn1), (MODE(2) |  RXACTIVE | PULLUP_EN)},	/* NAND_CS0 */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* NAND_CS0 */
+#ifndef CONFIG_AM335X_HTOUCH
+	{OFFSET(spi0_d0), (MODE(7) | PULLUP_EN | RXACTIVE)},	/* NAND_WPN */
+#endif
+	{-1},
+};
+
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(lcd_data0), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A0 */
+	{OFFSET(lcd_data1), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A1 */
+	{OFFSET(lcd_data2), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A2 */
+	{OFFSET(lcd_data3), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A3 */
+	{OFFSET(lcd_data4), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A4 */
+	{OFFSET(lcd_data5), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A5 */
+	{OFFSET(lcd_data6), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A6 */
+	{OFFSET(lcd_data7), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A7 */
+	{OFFSET(lcd_vsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A8 */
+	{OFFSET(lcd_hsync), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A9 */
+	{OFFSET(lcd_pclk), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A10 */
+	{OFFSET(lcd_ac_bias_en), MODE(1)| PULLUDEN | RXACTIVE},	/* NOR_A11 */
+	{OFFSET(lcd_data8), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A12 */
+	{OFFSET(lcd_data9), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A13 */
+	{OFFSET(lcd_data10), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A14 */
+	{OFFSET(lcd_data11), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A15 */
+	{OFFSET(lcd_data12), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A16 */
+	{OFFSET(lcd_data13), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A17 */
+	{OFFSET(lcd_data14), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A18 */
+	{OFFSET(lcd_data15), MODE(1) | PULLUDEN | RXACTIVE},	/* NOR_A19 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDEN | RXACTIVE},	/* NOR_AD15 */
+
+	{OFFSET(gpmc_csn0), (MODE(0) | PULLUDEN) | RXACTIVE},	/* NOR_CE */
+	{OFFSET(gpmc_advn_ale), (MODE(0) | PULLUDEN) | RXACTIVE}, /* NOR_ADVN_ALE */
+	{OFFSET(gpmc_oen_ren), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_OE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0) | PULLUDEN | RXACTIVE)},/* NOR_BE0N_CLE */
+	{OFFSET(gpmc_wen), (MODE(0) | PULLUDEN | RXACTIVE)},	/* NOR_WEN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUDEN)}, /* NOR WAIT */
+	{-1},
+};
+#endif
+
+/*
+static struct module_pin_mux gpio3_7_pin_mux[] = {
+	{OFFSET(emu0), MODE(7) | PULLUDDIS | RXACTIVE},	// gpio3_7 - used for WLAN IRQ
+	{-1},
+};*/
+
+
+static struct module_pin_mux gpios_pin_mux[] = {
+	{OFFSET(gpmc_be1n), MODE(7) | PULLUDEN | RXACTIVE},	// gpio1_28 - HeartBeat LED in Sink mode
+	{OFFSET(gpmc_clk), MODE(7) | PULLUDEN | RXACTIVE},	// gpio2_1 - Ethernet switch reset signal
+	{OFFSET(gpmc_csn3), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio2_0 - HDMI Transmitter INT signal
+	{OFFSET(mcasp0_aclkr), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_18 - Gigabit PHY reset signal
+	{OFFSET(mcasp0_ahclkx), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_21 - USB HUB reset signal
+	{OFFSET(mcasp0_fsr), MODE(7) | PULLUDEN | RXACTIVE},	// gpio3_19 - GPIO to set the PMIC in SLEEP state
+	{OFFSET(mcasp0_axr1), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio3_20 - Ethernet switch interrupt signal
+	{OFFSET(mii1_col), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio3_0 - Gigabit PHY interrupt signal
+	{OFFSET(mii1_txd2), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_17 - MCU reset signal
+	{OFFSET(mii1_txd3), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio0_16 - INT signal from PMIC
+	{OFFSET(spi0_cs0), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_5 - Shutdown status signal to MCU at the time of shutdown
+	{OFFSET(spi0_cs1), MODE(7) | PULLUP_EN | RXACTIVE},	// gpio0_6 - INT signal from Power switch IC - LTC2955C to shutdown the system
+	{OFFSET(spi0_d0), MODE(7) | PULLUDEN | RXACTIVE},	// gpio0_3 - eMMC  (MMC1) reset signal
+	{-1},
+};
+
+/*
+ * Configure the pin mux for the module
+ */
+static void configure_module_pin_mux(struct module_pin_mux *mod_pin_mux)
+{
+	int i;
+
+	if (!mod_pin_mux)
+		return;
+
+	for (i = 0; mod_pin_mux[i].reg_offset != -1; i++)
+		MUX_CFG(mod_pin_mux[i].val, mod_pin_mux[i].reg_offset);
+}
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+
+void enable_board_pin_mux(struct am335x_baseboard_id *header)
+{
+#ifdef CONFIG_AM335X_HTOUCH
+	/* DCIM */
+	printf("Using DCIM Pin Mux\n");
+	//configure_module_pin_mux(gpio0_7_pin_mux);
+	configure_module_pin_mux(gpios_pin_mux);
+	configure_module_pin_mux(i2c1_pin_mux);
+	configure_module_pin_mux(i2c2_pin_mux);
+	configure_module_pin_mux(nand_pin_mux);
+	configure_module_pin_mux(rgmii2_pin_mux);
+	configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	configure_module_pin_mux(mmc2_pin_mux);
+#else
+	/* Do board-specific muxes. */
+	if (!strncmp(header->name, "A335BONE", HDR_NAME_LEN)) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NOR) && !defined(CONFIG_NOR_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#endif
+	} else if (!strncmp(header->config, "SKU#01", 6)) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii2_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (!strncmp(header->name, "A335X_SK", HDR_NAME_LEN)) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(i2c2_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii2_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else {
+		puts("Unknown board, cannot configure pinmux.");
+		hang();
+	}
+#endif
+}
diff --git a/board/hetronic/htouch/pmic.h b/board/hetronic/htouch/pmic.h
new file mode 100644
index 0000000..b9851e8
--- /dev/null
+++ b/board/hetronic/htouch/pmic.h
@@ -0,0 +1,77 @@
+/*
+ * pmic.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef PMIC_h
+#define PMIC_H
+
+/*
+ * The PMIC on this board is a TPS65910.
+ */
+
+#define PMIC_SR_I2C_ADDR		0x12
+#define PMIC_CTRL_I2C_ADDR		0x2D
+/* PMIC Register offsets */
+#define PMIC_VDD1_REG			0x21
+#define PMIC_VDD1_OP_REG		0x22
+#define PMIC_VDD2_REG			0x24
+#define PMIC_VDD2_OP_REG		0x25
+#define PMIC_DEVCTRL_REG		0x3f
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define PMIC_VGAIN_SEL_MASK		(0x3 << 6)
+#define PMIC_ILMAX_MASK			(0x1 << 5)
+#define PMIC_TSTEP_MASK			(0x7 << 2)
+#define PMIC_ST_MASK			(0x3)
+
+#define PMIC_REG_VGAIN_SEL_X1		(0x0 << 6)
+#define PMIC_REG_VGAIN_SEL_X1_0		(0x1 << 6)
+#define PMIC_REG_VGAIN_SEL_X3		(0x2 << 6)
+#define PMIC_REG_VGAIN_SEL_X4		(0x3 << 6)
+
+#define PMIC_REG_ILMAX_1_0_A		(0x0 << 5)
+#define PMIC_REG_ILMAX_1_5_A		(0x1 << 5)
+
+#define PMIC_REG_TSTEP_			(0x0 << 2)
+#define PMIC_REG_TSTEP_12_5		(0x1 << 2)
+#define PMIC_REG_TSTEP_9_4		(0x2 << 2)
+#define PMIC_REG_TSTEP_7_5		(0x3 << 2)
+#define PMIC_REG_TSTEP_6_25		(0x4 << 2)
+#define PMIC_REG_TSTEP_4_7		(0x5 << 2)
+#define PMIC_REG_TSTEP_3_12		(0x6 << 2)
+#define PMIC_REG_TSTEP_2_5		(0x7 << 2)
+
+#define PMIC_REG_ST_OFF			(0x0)
+#define PMIC_REG_ST_ON_HI_POW		(0x1)
+#define PMIC_REG_ST_OFF_1		(0x2)
+#define PMIC_REG_ST_ON_LOW_POW		(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define PMIC_OP_REG_SEL				(0x7F)
+
+#define PMIC_OP_REG_CMD_MASK			(0x1 << 7)
+#define PMIC_OP_REG_CMD_OP			(0x0 << 7)
+#define PMIC_OP_REG_CMD_SR			(0x1 << 7)
+
+#define PMIC_OP_REG_SEL_MASK			(0x7F)
+#define PMIC_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define PMIC_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define PMIC_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_MASK	(0x1 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define PMIC_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+#endif
diff --git a/board/hetronic/htouch/tps65217.h b/board/hetronic/htouch/tps65217.h
new file mode 100644
index 0000000..8f2309a
--- /dev/null
+++ b/board/hetronic/htouch/tps65217.h
@@ -0,0 +1,92 @@
+/*
+ * (C) Copyright 2011
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __TPS65217_H__
+#define __TPS65217_H__
+
+#include <common.h>
+#include <i2c.h>
+
+/* I2C chip address */
+#define TPS65217_CHIP_PM		0x24
+
+/* Registers */
+#define CHIPID				0x00
+#define POWER_PATH			0x01
+#define INTERRUPT			0x02
+#define CHGCONFIG0			0x03
+#define CHGCONFIG1			0x04
+#define CHGCONFIG2			0x05
+#define CHGCONFIG3			0x06
+#define WLEDCTRL1			0x07
+#define WLEDCTRL2			0x08
+#define MUXCTRL				0x09
+#define STATUS				0x0A
+#define PASSWORD			0x0B
+#define PGOOD				0x0C
+#define DEFPG				0x0D
+#define DEFDCDC1			0x0E
+#define DEFDCDC2			0x0F
+#define DEFDCDC3			0x10
+#define DEFSLEW				0x11
+#define DEFLDO1				0x12
+#define DEFLDO2				0x13
+#define DEFLS1				0x14
+#define DEFLS2				0x15
+#define ENABLE				0x16
+#define DEFUVLO				0x18
+#define SEQ1				0x19
+#define SEQ2				0x1A
+#define SEQ3				0x1B
+#define SEQ4				0x1C
+#define SEQ5				0x1D
+#define SEQ6				0x1E
+
+#define PROT_LEVEL_NONE			0x00
+#define PROT_LEVEL_1			0x01
+#define PROT_LEVEL_2			0x02
+
+#define PASSWORD_LOCK_FOR_WRITE		0x00
+#define PASSWORD_UNLOCK			0x7D
+
+#define DCDC_GO				0x80
+
+#define MASK_ALL_BITS			0xFF
+
+#define USB_INPUT_CUR_LIMIT_MASK	0x03
+#define USB_INPUT_CUR_LIMIT_100MA	0x00
+#define USB_INPUT_CUR_LIMIT_500MA	0x01
+#define USB_INPUT_CUR_LIMIT_1300MA	0x02
+#define USB_INPUT_CUR_LIMIT_1800MA	0x03
+
+#define DCDC_VOLT_SEL_1125MV		0x09
+#define DCDC_VOLT_SEL_1275MV		0x0F
+#define DCDC_VOLT_SEL_1325MV		0x11
+
+#define LDO_MASK			0x1F
+#define LDO_VOLTAGE_OUT_1_8		0x06
+#define LDO_VOLTAGE_OUT_3_3		0x1F
+
+#define PWR_SRC_USB_BITMASK		0x4
+#define PWR_SRC_AC_BITMASK		0x8
+#endif
diff --git a/board/hetronic/htouch/tps65910.h b/board/hetronic/htouch/tps65910.h
new file mode 100644
index 0000000..f5fe744
--- /dev/null
+++ b/board/hetronic/htouch/tps65910.h
@@ -0,0 +1,76 @@
+/*
+ * (C) Copyright 2011-2013
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ *
+ * For more details, please see the TRM at http://www.ti.com/product/tps65910
+ */
+#ifndef __POWER_TPS65910_H__
+#define __POWER_TPS65910_H__
+
+#define MPU     0
+#define CORE    1
+
+#define TPS65910_SR_I2C_ADDR				0x12
+#define TPS65910_CTRL_I2C_ADDR				0x2D
+
+/* PMIC Register offsets */
+#define TPS65910_VDD1_REG				0x21
+#define TPS65910_VDD1_OP_REG				0x22
+#define TPS65910_VDD2_REG				0x24
+#define TPS65910_VDD2_OP_REG				0x25
+#define TPS65910_DEVCTRL_REG				0x3F
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define TPS65910_VGAIN_SEL_MASK				(0x3 << 6)
+#define TPS65910_ILMAX_MASK				(0x1 << 5)
+#define TPS65910_TSTEP_MASK				(0x7 << 2)
+#define TPS65910_ST_MASK				(0x3)
+
+#define TPS65910_REG_VGAIN_SEL_X1			(0x0 << 6)
+#define TPS65910_REG_VGAIN_SEL_X1_0			(0x1 << 6)
+#define TPS65910_REG_VGAIN_SEL_X3			(0x2 << 6)
+#define TPS65910_REG_VGAIN_SEL_X4			(0x3 << 6)
+
+#define TPS65910_REG_ILMAX_1_0_A			(0x0 << 5)
+#define TPS65910_REG_ILMAX_1_5_A			(0x1 << 5)
+
+#define TPS65910_REG_TSTEP_				(0x0 << 2)
+#define TPS65910_REG_TSTEP_12_5				(0x1 << 2)
+#define TPS65910_REG_TSTEP_9_4				(0x2 << 2)
+#define TPS65910_REG_TSTEP_7_5				(0x3 << 2)
+#define TPS65910_REG_TSTEP_6_25				(0x4 << 2)
+#define TPS65910_REG_TSTEP_4_7				(0x5 << 2)
+#define TPS65910_REG_TSTEP_3_12				(0x6 << 2)
+#define TPS65910_REG_TSTEP_2_5				(0x7 << 2)
+
+#define TPS65910_REG_ST_OFF				(0x0)
+#define TPS65910_REG_ST_ON_HI_POW			(0x1)
+#define TPS65910_REG_ST_OFF_1				(0x2)
+#define TPS65910_REG_ST_ON_LOW_POW			(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define TPS65910_OP_REG_SEL				(0x7F)
+
+#define TPS65910_OP_REG_CMD_MASK			(0x1 << 7)
+#define TPS65910_OP_REG_CMD_OP				(0x0 << 7)
+#define TPS65910_OP_REG_CMD_SR				(0x1 << 7)
+
+#define TPS65910_OP_REG_SEL_MASK			(0x7F)
+#define TPS65910_OP_REG_SEL_0_9_5			(0x1F)	/* 0.9500 V */
+#define TPS65910_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define TPS65910_OP_REG_SEL_1_2_0			(0x33)	/* 1.2000 V */
+#define TPS65910_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define TPS65910_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_MASK		(0x1 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+int tps65910_set_i2c_control(void);
+int tps65910_voltage_update(unsigned int module, unsigned char vddx_op_vol_sel);
+#endif	
+/* __POWER_TPS65910_H__ */
diff --git a/board/hetronic/htouch/u-boot.lds b/board/hetronic/htouch/u-boot.lds
new file mode 100644
index 0000000..b8379c8
--- /dev/null
+++ b/board/hetronic/htouch/u-boot.lds
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		__image_copy_start = .;
+		CPUDIR/start.o (.text*)
+		board/hetronic/htouch/libhtouch.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+	#include <u-boot.lst>
+	}
+
+	. = ALIGN(4);
+
+	__image_copy_end = .;
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss*)
+		 . = ALIGN(4);
+		__bss_end__ = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
+
+#if defined(CONFIG_SPL_TEXT_BASE) && defined(CONFIG_SPL_MAX_SIZE)
+ASSERT(__bss_end__ < (CONFIG_SPL_TEXT_BASE + CONFIG_SPL_MAX_SIZE), "SPL image too big");
+#endif
diff --git a/boards.cfg b/boards.cfg
index f07b7b4..670cbe0 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -244,6 +244,8 @@ am335x_evm_restore_flash     arm    armv7       am335x              ti
 am335x_evm_restore_flash_usbspl   arm    armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1,RESTORE_FLASH,SPL_USBETH_SUPPORT
 am335x_evm_uart_usbspl       arm    armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1,UART_THEN_USB_SPL,SPL_USBETH_SUPPORT
 am335x_evm_restore_flash_uart_usbspl       arm    armv7       am335x              ti             am33xx      am335x_evm:SERIAL1,CONS_INDEX=1,RESTORE_FLASH,UART_THEN_USB_SPL,SPL_USBETH_SUPPORT
+htouch                       arm         armv7       htouch              hetronic       am33xx      htouch:DFU_NAND
+dcim			     arm         armv7       dcim	         cti            am33xx      dcim:DFU_NAND
 highbank                     arm         armv7       highbank            -              highbank
 mx51_efikamx                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKAMX,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_mx.cfg
 mx51_efikasb                 arm         armv7       mx51_efikamx        genesi         mx5		mx51_efikamx:MACH_TYPE=MACH_TYPE_MX51_EFIKASB,IMX_CONFIG=board/genesi/mx51_efikamx/imximage_sb.cfg
diff --git a/common/spl/spl_nand.c b/common/spl/spl_nand.c
index 61de5a4..90efb46 100644
--- a/common/spl/spl_nand.c
+++ b/common/spl/spl_nand.c
@@ -46,10 +46,12 @@ void spl_nand_load_image(void)
 		 * CONFIG_CMD_SPL_WRITE_SIZE therefore may overwrite
 		 * following sections like BSS
 		 */
+		printf("Falcon: Loading Args...\n");
 		nand_spl_load_image(CONFIG_CMD_SPL_NAND_OFS,
 			CONFIG_CMD_SPL_WRITE_SIZE,
 			(void *)CONFIG_SYS_TEXT_BASE);
 		/* copy to destintion */
+		printf("Falcon: Copying to RAM...\n");
 		for (dst = (int *)CONFIG_SYS_SPL_ARGS_ADDR,
 				src = (int *)CONFIG_SYS_TEXT_BASE;
 				src < (int *)(CONFIG_SYS_TEXT_BASE +
@@ -59,14 +61,18 @@ void spl_nand_load_image(void)
 		}
 
 		/* load linux */
+		printf("Falcon: Loading Linux Header...\n");
 		nand_spl_load_image(CONFIG_SYS_NAND_SPL_KERNEL_OFFS,
 			CONFIG_SYS_NAND_PAGE_SIZE, (void *)header);
+		printf("Falcon: Parsing Linux Header...\n");
 		spl_parse_image_header(header);
 		if (header->ih_os == IH_OS_LINUX) {
 			/* happy - was a linux */
+			printf("Falcon: Linux Found, loading remaining image data (%i bytes)...\n", spl_image.size);
 			nand_spl_load_image(CONFIG_SYS_NAND_SPL_KERNEL_OFFS,
 				spl_image.size, (void *)spl_image.load_addr);
 			nand_deselect();
+			printf("Falcon: Linux transferred.\n");
 			return;
 		} else {
 			puts("The Expected Linux image was not "
diff --git a/common/spl/spl_net.c b/common/spl/spl_net.c
index e1596fe..b2fb315 100644
--- a/common/spl/spl_net.c
+++ b/common/spl/spl_net.c
@@ -33,7 +33,9 @@ void spl_net_load_image(const char *device)
 	int rv;
 
 	env_init();
+printf("env_relocate 1\n"); 
 	env_relocate();
+printf("env_relocate 2\n");
 	setenv("autoload", "yes");
 	load_addr = CONFIG_SYS_TEXT_BASE - sizeof(struct image_header);
 	rv = eth_initialize(gd->bd);
diff --git a/dcim.boards.cfg b/dcim.boards.cfg
new file mode 100644
index 0000000..f7c31c4
--- /dev/null
+++ b/dcim.boards.cfg
@@ -0,0 +1,2 @@
+dcim			     arm         armv7       dcim	         cti            am33xx      dcim:DFU_NAND
+htouch                       arm         armv7       htouch              hetronic       am33xx      htouch:DFU_NAND
diff --git a/drivers/i2c/omap24xx_i2c.c b/drivers/i2c/omap24xx_i2c.c
index 54e9b15..14d5570 100644
--- a/drivers/i2c/omap24xx_i2c.c
+++ b/drivers/i2c/omap24xx_i2c.c
@@ -40,7 +40,11 @@ static void flush_fifo(void);
  * variables to live in SRAM
  */
 static struct i2c __attribute__((section (".data"))) *i2c_base =
+#ifdef CONFIG_AM335X_DCIM
+					(struct i2c *)I2C_BASE2;
+#else
 					(struct i2c *)I2C_DEFAULT_BASE;
+#endif
 static unsigned int __attribute__((section (".data"))) bus_initialized[I2C_BUS_MAX] =
 					{ [0 ... (I2C_BUS_MAX-1)] = 0 };
 static unsigned int __attribute__((section (".data"))) current_bus = 0;
diff --git a/drivers/mmc/spl_mmc.c b/drivers/mmc/spl_mmc.c
index 753c6a0..03885a8 100644
--- a/drivers/mmc/spl_mmc.c
+++ b/drivers/mmc/spl_mmc.c
@@ -32,7 +32,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-static void mmc_load_image_raw(struct mmc *mmc)
+static int mmc_load_image_raw(struct mmc *mmc, unsigned long sector)
 {
 	u32 image_size_sectors, err;
 	const struct image_header *header;
@@ -41,9 +41,7 @@ static void mmc_load_image_raw(struct mmc *mmc)
 						sizeof(struct image_header));
 
 	/* read image header to find the image size & load address */
-	err = mmc->block_dev.block_read(0,
-			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR, 1,
-			(void *)header);
+	err = mmc->block_dev.block_read(0, sector, 1, (void *)header);
 
 	if (err <= 0)
 		goto end;
@@ -55,19 +53,33 @@ static void mmc_load_image_raw(struct mmc *mmc)
 				mmc->read_bl_len;
 
 	/* Read the header too to avoid extra memcpy */
-	err = mmc->block_dev.block_read(0,
-			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR,
-			image_size_sectors, (void *)spl_image.load_addr);
+	err = mmc->block_dev.block_read(0, sector, image_size_sectors,
+					(void *)spl_image.load_addr);
 
 end:
-	if (err <= 0) {
+	if (err <= 0)
 		printf("spl: mmc blk read err - %d\n", err);
-		hang();
+	
+	return (err <= 0);
+}
+
+#ifdef CONFIG_SPL_OS_BOOT
+static int mmc_load_image_raw_os(struct mmc *mmc)
+{
+	if (!mmc->block_dev.block_read(0,
+				       CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR,
+				       CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS,
+				       (void *)CONFIG_SYS_SPL_ARGS_ADDR)) {
+		printf("mmc args blk read error\n");
+		return -1;
 	}
+
+	return mmc_load_image_raw(mmc, CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR);
 }
+#endif
 
 #ifdef CONFIG_SPL_FAT_SUPPORT
-static void mmc_load_image_fat(struct mmc *mmc)
+static int mmc_load_image_fat(struct mmc *mmc, const char *filename)
 {
 	s32 err;
 	struct image_header *header;
@@ -75,32 +87,41 @@ static void mmc_load_image_fat(struct mmc *mmc)
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE -
 						sizeof(struct image_header));
 
-	err = fat_register_device(&mmc->block_dev,
-				CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
-	if (err) {
-		printf("spl: fat register err - %d\n", err);
-		hang();
-	}
-
-	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
-				(u8 *)header, sizeof(struct image_header));
+	err = file_fat_read(filename, (u8 *)header, sizeof(struct image_header));
 	if (err <= 0)
 		goto end;
 
 	spl_parse_image_header(header);
 
-	err = file_fat_read(CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME,
-				(u8 *)spl_image.load_addr, 0);
+	err = file_fat_read(filename, (u8 *)spl_image.load_addr, 0);
 
 end:
+	if (err <= 0)
+		printf("spl: error reading image %s, err - %d\n",
+			filename, err);
+
+	return (err <= 0);
+}
+
+#ifdef CONFIG_SPL_OS_BOOT
+static int mmc_load_image_fat_os(struct mmc *mmc)
+{
+	int err;
+
+	err = file_fat_read(CONFIG_SPL_FAT_LOAD_ARGS_NAME,
+			    (void *)CONFIG_SYS_SPL_ARGS_ADDR, 0);
 	if (err <= 0) {
 		printf("spl: error reading image %s, err - %d\n",
-			CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME, err);
-		hang();
+		       CONFIG_SPL_FAT_LOAD_ARGS_NAME, err);
+		return -1;
 	}
+
+	return mmc_load_image_fat(mmc, CONFIG_SPL_FAT_LOAD_KERNEL_NAME);
 }
 #endif
 
+#endif
+
 void spl_mmc_load_image(void)
 {
 	struct mmc *mmc;
@@ -120,17 +141,36 @@ void spl_mmc_load_image(void)
 		printf("spl: mmc init failed: err - %d\n", err);
 		hang();
 	}
+
 	boot_mode = spl_boot_mode();
 	if (boot_mode == MMCSD_MODE_RAW) {
 		debug("boot mode - RAW\n");
-		mmc_load_image_raw(mmc);
+#ifdef CONFIG_SPL_OS_BOOT
+		if (spl_start_uboot() || mmc_load_image_raw_os(mmc))
+#endif
+		err = mmc_load_image_raw(mmc,
+					 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR);
 #ifdef CONFIG_SPL_FAT_SUPPORT
 	} else if (boot_mode == MMCSD_MODE_FAT) {
 		debug("boot mode - FAT\n");
-		mmc_load_image_fat(mmc);
+
+		err = fat_register_device(&mmc->block_dev,
+					  CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION);
+		if (err) {
+			printf("spl: fat register err - %d\n", err);
+			hang();
+		}
+
+#ifdef CONFIG_SPL_OS_BOOT
+		if (spl_start_uboot() || mmc_load_image_fat_os(mmc))
+#endif
+		err = mmc_load_image_fat(mmc, CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME);
 #endif
 	} else {
 		puts("spl: wrong MMC boot mode\n");
 		hang();
 	}
+
+	if (err)
+		hang();
 }
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 4b27198..f362fe2 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -284,6 +284,57 @@ static int m88e1111s_config(struct phy_device *phydev)
 	return 0;
 }
 
+/**
+ * m88e1518_phy_writebits - write bits to a register
+ */
+void m88e1518_phy_writebits(struct phy_device *phydev,
+		   u8 reg_num, u16 offset, u16 len, u16 data)
+{
+	u16 reg, mask;
+
+	if ((len + offset) >= 16)
+		mask = 0 - (1 << offset);
+	else
+	mask = (1 << (len + offset)) - (1 << offset);
+
+	reg = phy_read(phydev, MDIO_DEVAD_NONE, reg_num);
+
+	reg &= ~mask;
+	reg |= data << offset;
+
+	phy_write(phydev, MDIO_DEVAD_NONE, reg_num, reg);
+}
+
+static int m88e1518_config(struct phy_device *phydev)
+{
+	/*
+	 * As per Marvell Release Notes - Alaska 88E1510/88E1518/88E1512/88E1514
+	 * Rev A0, Errata Section 3.1
+	 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 22, 0x00ff);	/* reg page 0xff */
+	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x214B);
+	phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2144);
+	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x0C28);
+	phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2146);
+	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0xB233);
+	phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x214D);
+	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0xCC0C);
+	phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2159);
+	phy_write(phydev, MDIO_DEVAD_NONE, 22, 0x0000);	/* reg page 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 22, 18);	/* reg page 18 */
+	/* Write HWCFG_MODE = SGMII to Copper */
+	m88e1518_phy_writebits(phydev, 20, 0, 3, 1);
+
+	/* Phy reset */
+	m88e1518_phy_writebits(phydev, 20, 15, 1, 1);
+	phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);	/* reg page 18 */
+	udelay(100);
+
+	return m88e1111s_config(phydev);
+}
+
+
+
 /* Marvell 88E1118 */
 static int m88e1118_config(struct phy_device *phydev)
 {
@@ -465,6 +516,17 @@ static struct phy_driver M88E1149S_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
+
+static struct phy_driver M88E1518_driver = {
+	.name = "Marvell 88E1518",
+ 	.uid = 0x1410dd1,
+ 	.mask = 0xffffff0,
+ 	.features = PHY_GBIT_FEATURES,
+	.config = &m88e1518_config,
+ 	.startup = &m88e1011s_startup,
+ 	.shutdown = &genphy_shutdown,
+ };
+
 int phy_marvell_init(void)
 {
 	phy_register(&M88E1149S_driver);
@@ -474,6 +536,6 @@ int phy_marvell_init(void)
 	phy_register(&M88E1118R_driver);
 	phy_register(&M88E1111S_driver);
 	phy_register(&M88E1011S_driver);
-
+	phy_register(&M88E1518_driver);
 	return 0;
 }
diff --git a/drivers/usb/musb-new/musb_core.c b/drivers/usb/musb-new/musb_core.c
index 040a5c0..46ff244 100644
--- a/drivers/usb/musb-new/musb_core.c
+++ b/drivers/usb/musb-new/musb_core.c
@@ -1439,7 +1439,7 @@ static int __devinit musb_core_init(u16 musb_type, struct musb *musb)
 	}
 	if (reg & MUSB_CONFIGDATA_SOFTCONE)
 		strcat(aInfo, ", SoftConn");
-
+	printk("waman");
 	printk(KERN_DEBUG "%s: ConfigData=0x%02x (%s)\n",
 			musb_driver_name, reg, aInfo);
 
diff --git a/include/configs/dcim.h b/include/configs/dcim.h
new file mode 100644
index 0000000..e6f6f13
--- /dev/null
+++ b/include/configs/dcim.h
@@ -0,0 +1,594 @@
+/*
+ * dcim.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ * DCIM Modifications Copyright (C) 2014 Methode Electronics
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CONFIG_DCIM_H
+#define __CONFIG_DCIM_H
+
+#define CONFIG_AM33XX
+#define CONFIG_AM335X_DCIM
+
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+
+/*#define CONFIG_SYS_DCACHE_OFF*/
+
+#define CONFIG_DMA_COHERENT
+#define CONFIG_DMA_COHERENT_SIZE	(1 << 20)
+
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128 KiB */
+#define CONFIG_SYS_MALLOC_LEN		(1024 << 10)
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT		"U-Boot# "
+#undef CONFIG_BOARD_LATE_INIT
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_MACH_TYPE_DCIM		4677
+#define CONFIG_MACH_TYPE		CONFIG_MACH_TYPE_DCIM
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Custom script for NOR */
+#define CONFIG_SYS_LDSCRIPT		"board/cti/dcim/u-boot.lds"
+
+#define CONFIG_SYS_CACHELINE_SIZE       64
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_VERSION_VARIABLE
+
+/* set to negative value for no autoboot */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x82000000\0" \
+	"kloadaddr=0x80007fc0\0" \
+	"fdtaddr=0x80F80000\0" \
+	"fdt_high=0xffffffff\0" \
+	"rdaddr=0x81000000\0" \
+	"bootfile=uImage\0" \
+	"fdtfile=\0" \
+	"console=ttyO0,115200n8\0" \
+	"optargs=vt.global_cursor_default=0\0" \
+	"mtdids=" MTDIDS_DEFAULT "\0" \
+	"mtdparts=" MTDPARTS_DEFAULT "\0" \
+	"dfu_alt_info_mmc=" DFU_ALT_INFO_MMC "\0" \
+	"dfu_alt_info_emmc=rawemmc mmc 0 3751936\0" \
+	"dfu_alt_info_nand=" DFU_ALT_INFO_NAND "\0" \
+	"mmcdev=0\0" \
+	"mmcroot=/dev/mmcblk0p2 rw\0" \
+	"mmcrootfstype=ext3 rootwait\0" \
+	"nandroot=ubi0:rootfs rw ubi.mtd=7,2048\0" \
+	"nandrootfstype=ubifs rootwait=1\0" \
+	"nandsrcaddr=0x280000\0" \
+	"nandimgsize=0x500000\0" \
+	"rootpath=/export/rootfs\0" \
+	"nfsopts=nolock\0" \
+	"static_ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}" \
+		"::off\0" \
+	"ramroot=/dev/ram0 rw ramdisk_size=65536 initrd=${rdaddr},64M\0" \
+	"ramrootfstype=ext2\0" \
+	"ip_metethod=dhcp\0" \
+	"bootargs_defaults=setenv bootargs " \
+		"console=${console} " \
+		"${optargs}\0" \
+	"mmcargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${mmcroot} " \
+		"rootfstype=${mmcrootfstype} ip=${ip_method}\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${nandroot} " \
+		"rootfstype=${nandrootfstype}\0" \
+	"spiroot=/dev/mtdblock4 rw\0" \
+	"spirootfstype=jffs2\0" \
+	"spisrcaddr=0xe0000\0" \
+	"spiimgsize=0x362000\0" \
+	"spibusno=0\0" \
+	"spiargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${spiroot} " \
+		"rootfstype=${spirootfstype}\0" \
+	"netargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=/dev/nfs " \
+		"nfsroot=${serverip}:${rootpath},${nfsopts} rw " \
+		"ip=dhcp\0" \
+	"bootenv=uEnv.txt\0" \
+	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenv}\0" \
+	"importbootenv=echo Importing environment from mmc ...; " \
+		"env import -t $loadaddr $filesize\0" \
+	"ramargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${ramroot} " \
+		"rootfstype=${ramrootfstype}\0" \
+	"loadramdisk=fatload mmc ${mmcdev} ${rdaddr} ramdisk.gz\0" \
+	"loaduimagefat=fatload mmc ${mmcdev} ${kloadaddr} ${bootfile}\0" \
+	"loaduimage=ext2load mmc ${mmcdev}:2 ${kloadaddr} /boot/${bootfile}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${kloadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} ${nandsrcaddr} ${nandimgsize}; " \
+		"bootm ${loadaddr}\0" \
+	"spiboot=echo Booting from spi ...; " \
+		"run spiargs; " \
+		"sf probe ${spibusno}:0; " \
+		"sf read ${loadaddr} ${spisrcaddr} ${spiimgsize}; " \
+		"bootm ${loadaddr}\0" \
+	"netboot=echo Booting from network ...; " \
+		"setenv autoload no; " \
+		"dhcp; " \
+		"tftp ${loadaddr} ${bootfile}; " \
+		"run netargs; " \
+		"bootm ${loadaddr}\0" \
+	"ramboot=echo Booting from ramdisk ...; " \
+		"run ramargs; " \
+		"bootm ${loadaddr}\0" \
+	"findfdt="\
+		"if test $board_name = A335BONE; then " \
+			"setenv fdtfile am335x-bone.dtb; fi; " \
+		"if test $board_name = A33515BB; then " \
+			"setenv fdtfile am335x-evm.dtb; fi; " \
+		"if test $board_name = A335X_SK; then " \
+			"setenv fdtfile am335x-evmsk.dtb; fi\0" \
+
+#endif
+
+#ifndef CONFIG_RESTORE_FLASH
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev}; if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmcdev};" \
+		"if run loadbootenv; then " \
+			"echo Loaded environment from ${bootenv};" \
+			"run importbootenv;" \
+		"fi;" \
+		"if test -n $uenvcmd; then " \
+			"echo Running uenvcmd ...;" \
+			"run uenvcmd;" \
+		"fi;" \
+		"if run loaduimagefat; then " \
+			"run mmcboot;" \
+		"elif run loaduimage; then " \
+			"run mmcboot;" \
+		"else " \
+			"echo Could not find ${bootfile} ;" \
+		"fi;" \
+	"else " \
+		"run nandboot;" \
+	"fi;" \
+
+#else
+
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY		0
+
+#ifdef CONFIG_SPL_USBETH_SUPPORT
+#define CONFIG_BOOTCOMMAND \
+	"setenv autoload no; " \
+	"setenv ethact usb_ether; " \
+	"dhcp; "	\
+	"if tftp 80000000 debrick.scr; then "	\
+		"source 80000000; "	\
+	"fi"
+#else
+#define CONFIG_BOOTCOMMAND \
+	"setenv autoload no; " \
+	"setenv ethact cpsw; " \
+	"dhcp; "	\
+	"if tftp 80000000 debrick.scr; then "	\
+		"source 80000000; "	\
+	"fi"
+#endif
+#endif
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define CONFIG_CMD_ECHO
+
+/* max number of command args */
+#define CONFIG_SYS_MAXARGS		16
+
+/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE \
+					+ sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+/*
+ * memtest works on 8 MB in DRAM after skipping 32MB from
+ * start addr of ram disk
+ */
+#define CONFIG_SYS_MEMTEST_START	(PHYS_DRAM_1 + (64 * 1024 * 1024))
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START \
+					+ (8 * 1024 * 1024))
+
+#define CONFIG_SYS_LOAD_ADDR		0x81000000 /* Default load address */
+#define CONFIG_SYS_HZ			1000 /* 1ms clock */
+
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_OMAP_HSMMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_SPI
+#define CONFIG_OMAP3_SPI
+#define CONFIG_MTD_DEVICE
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		(24000000)
+
+/* USB Composite download gadget - g_dnl */
+#define CONFIG_USB_GADGET
+#define CONFIG_USBDOWNLOAD_GADGET
+
+/* USB TI's IDs */
+#define CONFIG_USBD_HS
+#define CONFIG_G_DNL_VENDOR_NUM 0x0403
+#define CONFIG_G_DNL_PRODUCT_NUM 0xBD00
+#define CONFIG_G_DNL_MANUFACTURER "Texas Instruments"
+
+/* USB Device Firmware Update support */
+#define CONFIG_DFU_FUNCTION
+#define CONFIG_DFU_MMC
+/* #define CONFIG_DFU_NAND*/
+#define CONFIG_CMD_DFU
+#define DFU_ALT_INFO_MMC \
+	"boot part 0 1;" \
+	"rootfs part 0 2;" \
+	"MLO fat 0 1;" \
+	"MLO.raw mmc 100 100;" \
+	"u-boot.img.raw mmc 300 3C0;" \
+	"u-boot.img fat 0 1;" \
+	"uEnv.txt fat 0 1"
+#define DFU_ALT_INFO_NAND \
+	"SPL part 0 1;" \
+	"SPL.backup1 part 0 2;" \
+	"SPL.backup2 part 0 3;" \
+	"SPL.backup3 part 0 4;" \
+	"u-boot part 0 5;" \
+	"kernel part 0 7;" \
+	"rootfs part 0 8"
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1		/*  1 bank of DRAM */
+#define PHYS_DRAM_1			0x80000000	/* DRAM Bank #1 */
+#define CONFIG_MAX_RAM_BANK_SIZE	(1024 << 20)	/* 1GB */
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_DRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR         (NON_SECURE_SRAM_END - \
+						GENERATED_GBL_DATA_SIZE)
+ /* Platform/Board specific defs */
+#define CONFIG_SYS_TIMERBASE		0x48040000	/* Use Timer2 */
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SERIAL_MULTI
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		(48000000)
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2		0x48022000	/* UART1 */
+#define CONFIG_SYS_NS16550_COM3		0x48024000	/* UART2 */
+#define CONFIG_SYS_NS16550_COM4		0x481a6000	/* UART3 */
+#define CONFIG_SYS_NS16550_COM5		0x481a8000	/* UART4 */
+#define CONFIG_SYS_NS16550_COM6		0x481aa000	/* UART5 */
+#define CONFIG_SERIAL1
+#define CONFIG_CONS_INDEX		1
+
+/* I2C Configuration */
+#define CONFIG_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_DRIVER_OMAP24XX_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* Main EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+
+#define CONFIG_OMAP_GPIO
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 110, 300, 600, 1200, 2400, \
+4800, 9600, 14400, 19200, 28800, 38400, 56000, 57600, 115200 }
+
+#define CONFIG_ENV_OVERWRITE		1
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+#define CONFIG_ENV_IS_NOWHERE
+
+#ifndef CONFIG_NOR_BOOT
+/* Defines for SPL */
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_TEXT_BASE		0x402F0400
+#define CONFIG_SPL_MAX_SIZE		(101 * 1024)
+#define CONFIG_SPL_STACK		CONFIG_SYS_INIT_SP_ADDR
+
+#define CONFIG_SPL_OS_BOOT
+#define CONFIG_SPL_BSS_START_ADDR	0x80a00000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000		/* 512 KB */
+
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x300 /* address 0x60000 */
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS	0x200 /* 256 KB */
+#define CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION	1
+#define CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME	"u-boot.img"
+
+#ifdef CONFIG_SPL_OS_BOOT
+#define CONFIG_SYS_SPL_ARGS_ADDR		(PHYS_DRAM_1 + 0x100)
+/* fat */
+#define CONFIG_SPL_FAT_LOAD_KERNEL_NAME		"uImage"
+#define CONFIG_SPL_FAT_LOAD_ARGS_NAME		"args"
+/* raw mmc */
+#define CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR	0x500 /* address 0xa0000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR	0x8   /* address 0x1000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS	8     /* 4KB */
+/* nand */
+#define CONFIG_CMD_SPL_NAND_OFS			0x240000 /* end of u-boot */
+#define CONFIG_SYS_NAND_SPL_KERNEL_OFFS		0x280000
+#define CONFIG_CMD_SPL_WRITE_SIZE		0x1000
+/* spl export command */
+#define CONFIG_CMD_SPL
+#endif
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_FAT_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_YMODEM_SUPPORT
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_NET_VCI_STRING	"AM335x U-Boot SPL"
+#define CONFIG_SPL_ETH_SUPPORT
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		0
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x80000
+/*#define CONFIG_SPL_MUSB_NEW_SUPPORT*/
+#define CONFIG_SPL_LDSCRIPT		"$(CPUDIR)/omap-common/u-boot-spl.lds"
+
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SPL_NAND_AM33XX_BCH
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_DRIVERS
+#define CONFIG_SPL_NAND_ECC
+#endif
+
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_OOBSIZE		64
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128*1024)
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{ 2, 3, 4, 5, 6, 7, 8, 9, \
+					 10, 11, 12, 13, 14, 15, 16, 17, \
+					 18, 19, 20, 21, 22, 23, 24, 25, \
+					 26, 27, 28, 29, 30, 31, 32, 33, \
+					 34, 35, 36, 37, 38, 39, 40, 41, \
+					 42, 43, 44, 45, 46, 47, 48, 49, \
+					 50, 51, 52, 53, 54, 55, 56, 57, }
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	14
+
+#define CONFIG_SYS_NAND_ECCSTEPS	4
+#define	CONFIG_SYS_NAND_ECCTOTAL	(CONFIG_SYS_NAND_ECCBYTES * \
+						CONFIG_SYS_NAND_ECCSTEPS)
+
+#define	CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x80000
+
+/*
+ * 1MB into the SDRAM to allow for SPL's bss at the beginning of SDRAM
+ * 64 bytes before this address should be set aside for u-boot.img's
+ * header. That is 0x800FFFC0--0x80100000 should not be used for any
+ * other needs.
+ */
+#ifdef CONFIG_NOR_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x08000000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x80800000
+#endif
+#define CONFIG_SYS_SPL_MALLOC_START	0x80a08000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+
+/* Since SPL did pll and ddr initialization for us,
+ * we don't need to do it twice.
+ */
+#if !defined(CONFIG_SPL_BUILD) && ! defined(CONFIG_NOR_BOOT)
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * USB configuration
+ */
+#ifndef CONFIG_SPL_BUILD
+
+#define CONFIG_USB_MUSB_DSPS
+#define CONFIG_ARCH_MISC_INIT
+#define CONFIG_MUSB_GADGET
+#define CONFIG_MUSB_PIO_ONLY
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+#define CONFIG_MUSB_HOST
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE	MUSB_PERIPHERAL
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE MUSB_HOST
+
+#ifdef CONFIG_MUSB_HOST
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#endif
+
+#ifdef CONFIG_MUSB_GADGET
+#define CONFIG_USB_ETHER
+#define CONFIG_USB_ETH_RNDIS
+#define CONFIG_USBNET_HOST_ADDR	"de:ad:be:af:00:00"
+#endif /* CONFIG_MUSB_GADGET */
+
+#endif
+
+/*
+ * Default to using SPI for environment, etc.  We have multiple copies
+ * of SPL as the ROM will check these locations.
+ * 0x0 - 0x20000 : First copy of SPL
+ * 0x20000 - 0x40000 : Second copy of SPL
+ * 0x40000 - 0x60000 : Third copy of SPL
+ * 0x60000 - 0x80000 : Fourth copy of SPL
+ * 0x80000 - 0xDF000 : U-Boot
+ * 0xDF000 - 0xE0000 : U-Boot Environment
+ * 0xE0000 - 0x442000 : Linux Kernel
+ * 0x442000 - 0x800000 : Userland
+ */
+#if defined(CONFIG_SPI_BOOT)
+# undef CONFIG_ENV_IS_NOWHERE
+# define CONFIG_ENV_IS_IN_SPI_FLASH
+# define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+# define CONFIG_ENV_OFFSET		(892 << 10) /* 892 KiB in */
+# define CONFIG_ENV_SECT_SIZE		(4 << 10) /* 4 KB sectors */
+#endif /* SPI support */
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT)
+/* disable host part of MUSB in SPL */
+#undef CONFIG_MUSB_HOST
+/*
+ * Disable UART SPL support so we fit within the 101KiB limit.
+ */
+#undef CONFIG_SPL_ETH_SUPPORT
+#endif
+
+/* Unsupported features */
+#undef CONFIG_USE_IRQ
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+#define CONFIG_DRIVER_TI_CPSW
+#define CONFIG_MII
+#define CONFIG_CMD_MII
+#define CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_NET_RETRY_COUNT         10
+#define CONFIG_NET_MULTI
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ADDR			0
+#define CONFIG_PHY_SMSC
+
+#define CONFIG_NAND
+/* NAND support */
+#ifdef CONFIG_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_MTDPARTS
+#define MTDIDS_DEFAULT			"nand0=omap2-nand.0"
+#define MTDPARTS_DEFAULT		"mtdparts=omap2-nand.0:128k(SPL)," \
+					"128k(SPL.backup1)," \
+					"128k(SPL.backup2)," \
+					"128k(SPL.backup3),1792k(u-boot)," \
+					"128k(u-boot-spl-os)," \
+					"128k(u-boot-env),5m(kernel),-(rootfs)"
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_SYS_NAND_BASE		(0x08000000)	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND
+							   devices */
+#if !defined(CONFIG_SPI_BOOT) && !defined(CONFIG_NOR_BOOT)
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x260000 /* environment starts here */
+#define CONFIG_SYS_ENV_SECT_SIZE	(128 << 10)	/* 128 KiB */
+#endif
+#endif
+
+/*
+ *  * NOR Size = 16 MB
+ *   * No.Of Sectors/Blocks = 128
+ *    * Sector Size = 128 KB
+ *     * Word lenght = 16 bits
+ *      */
+#if defined(CONFIG_NOR)
+#undef CONFIG_SYS_NO_FLASH
+#undef CONFIG_SYS_MALLOC_LEN
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_MALLOC_LEN		(0x100000)
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_SYS_MAX_FLASH_SECT	128
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BASE		(0x08000000)
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_FLASH_BASE
+#define NOR_SECT_SIZE			(128 * 1024)
+#ifdef CONFIG_NOR_BOOT
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_FLASH  1
+#define CONFIG_SYS_ENV_SECT_SIZE	(2 * NOR_SECT_SIZE)
+#define CONFIG_ENV_SECT_SIZE		(2 * NOR_SECT_SIZE)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(2 * NOR_SECT_SIZE) /* After 1 MB */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + \
+         CONFIG_ENV_OFFSET)
+#endif
+#define CONFIG_MTD_DEVICE
+#define CONFIG_CMD_FLASH
+#endif  /* NOR support */
+
+#endif	/* ! __CONFIG_DCIM_H */
diff --git a/include/configs/htouch.h b/include/configs/htouch.h
new file mode 100644
index 0000000..e1df4e0
--- /dev/null
+++ b/include/configs/htouch.h
@@ -0,0 +1,594 @@
+/*
+ * htouch.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ * H-Touch Modifications Copyright (C) 2013 Hetronic International
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CONFIG_HTOUCH_H
+#define __CONFIG_HTOUCH_H
+
+#define CONFIG_AM33XX
+#define CONFIG_AM335X_HTOUCH
+
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+
+/*#define CONFIG_SYS_DCACHE_OFF*/
+
+#define CONFIG_DMA_COHERENT
+#define CONFIG_DMA_COHERENT_SIZE	(1 << 20)
+
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128 KiB */
+#define CONFIG_SYS_MALLOC_LEN		(1024 << 10)
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT		"U-Boot# "
+#undef CONFIG_BOARD_LATE_INIT
+#define CONFIG_SYS_NO_FLASH
+#define CONFIG_MACH_TYPE_HTOUCH		4678
+#define CONFIG_MACH_TYPE		CONFIG_MACH_TYPE_HTOUCH
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs */
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+
+/* Custom script for NOR */
+#define CONFIG_SYS_LDSCRIPT		"board/hetronic/htouch/u-boot.lds"
+
+#define CONFIG_SYS_CACHELINE_SIZE       64
+
+/* commands to include */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_VERSION_VARIABLE
+
+/* set to negative value for no autoboot */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_ENV_VARS_UBOOT_CONFIG
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x80200000\0" \
+	"kloadaddr=0x80007fc0\0" \
+	"fdtaddr=0x80F80000\0" \
+	"fdt_high=0xffffffff\0" \
+	"rdaddr=0x81000000\0" \
+	"bootfile=uImage\0" \
+	"fdtfile=\0" \
+	"console=ttyO0,115200n8\0" \
+	"optargs=vt.global_cursor_default=0\0" \
+	"mtdids=" MTDIDS_DEFAULT "\0" \
+	"mtdparts=" MTDPARTS_DEFAULT "\0" \
+	"dfu_alt_info_mmc=" DFU_ALT_INFO_MMC "\0" \
+	"dfu_alt_info_emmc=rawemmc mmc 0 3751936\0" \
+	"dfu_alt_info_nand=" DFU_ALT_INFO_NAND "\0" \
+	"mmcdev=0\0" \
+	"mmcroot=/dev/mmcblk0p2 ro\0" \
+	"mmcrootfstype=ext3 rootwait\0" \
+	"nandroot=ubi0:rootfs rw ubi.mtd=7,2048\0" \
+	"nandrootfstype=ubifs rootwait=1\0" \
+	"nandsrcaddr=0x280000\0" \
+	"nandimgsize=0x500000\0" \
+	"rootpath=/export/rootfs\0" \
+	"nfsopts=nolock\0" \
+	"static_ip=${ipaddr}:${serverip}:${gatewayip}:${netmask}:${hostname}" \
+		"::off\0" \
+	"ramroot=/dev/ram0 rw ramdisk_size=65536 initrd=${rdaddr},64M\0" \
+	"ramrootfstype=ext2\0" \
+	"ip_metethod=none\0" \
+	"bootargs_defaults=setenv bootargs " \
+		"console=${console} " \
+		"${optargs}\0" \
+	"mmcargs=run bootargs_defaults;" \
+		"setenv bootargs ${bootargs} " \
+		"root=${mmcroot} " \
+		"rootfstype=${mmcrootfstype} ip=${ip_method}\0" \
+	"nandargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${nandroot} " \
+		"rootfstype=${nandrootfstype}\0" \
+	"spiroot=/dev/mtdblock4 rw\0" \
+	"spirootfstype=jffs2\0" \
+	"spisrcaddr=0xe0000\0" \
+	"spiimgsize=0x362000\0" \
+	"spibusno=0\0" \
+	"spiargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${spiroot} " \
+		"rootfstype=${spirootfstype}\0" \
+	"netargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=/dev/nfs " \
+		"nfsroot=${serverip}:${rootpath},${nfsopts} rw " \
+		"ip=dhcp\0" \
+	"bootenv=uEnv.txt\0" \
+	"loadbootenv=fatload mmc ${mmcdev} ${loadaddr} ${bootenv}\0" \
+	"importbootenv=echo Importing environment from mmc ...; " \
+		"env import -t $loadaddr $filesize\0" \
+	"ramargs=setenv bootargs console=${console} " \
+		"${optargs} " \
+		"root=${ramroot} " \
+		"rootfstype=${ramrootfstype}\0" \
+	"loadramdisk=fatload mmc ${mmcdev} ${rdaddr} ramdisk.gz\0" \
+	"loaduimagefat=fatload mmc ${mmcdev} ${kloadaddr} ${bootfile}\0" \
+	"loaduimage=ext2load mmc ${mmcdev}:2 ${kloadaddr} /boot/${bootfile}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootm ${kloadaddr}\0" \
+	"nandboot=echo Booting from nand ...; " \
+		"run nandargs; " \
+		"nand read ${loadaddr} ${nandsrcaddr} ${nandimgsize}; " \
+		"bootm ${loadaddr}\0" \
+	"spiboot=echo Booting from spi ...; " \
+		"run spiargs; " \
+		"sf probe ${spibusno}:0; " \
+		"sf read ${loadaddr} ${spisrcaddr} ${spiimgsize}; " \
+		"bootm ${loadaddr}\0" \
+	"netboot=echo Booting from network ...; " \
+		"setenv autoload no; " \
+		"dhcp; " \
+		"tftp ${loadaddr} ${bootfile}; " \
+		"run netargs; " \
+		"bootm ${loadaddr}\0" \
+	"ramboot=echo Booting from ramdisk ...; " \
+		"run ramargs; " \
+		"bootm ${loadaddr}\0" \
+	"findfdt="\
+		"if test $board_name = A335BONE; then " \
+			"setenv fdtfile am335x-bone.dtb; fi; " \
+		"if test $board_name = A33515BB; then " \
+			"setenv fdtfile am335x-evm.dtb; fi; " \
+		"if test $board_name = A335X_SK; then " \
+			"setenv fdtfile am335x-evmsk.dtb; fi\0" \
+
+#endif
+
+#ifndef CONFIG_RESTORE_FLASH
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev}; if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmcdev};" \
+		"if run loadbootenv; then " \
+			"echo Loaded environment from ${bootenv};" \
+			"run importbootenv;" \
+		"fi;" \
+		"if test -n $uenvcmd; then " \
+			"echo Running uenvcmd ...;" \
+			"run uenvcmd;" \
+		"fi;" \
+		"if run loaduimagefat; then " \
+			"run mmcboot;" \
+		"elif run loaduimage; then " \
+			"run mmcboot;" \
+		"else " \
+			"echo Could not find ${bootfile} ;" \
+		"fi;" \
+	"else " \
+		"run nandboot;" \
+	"fi;" \
+
+#else
+
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY		0
+
+#ifdef CONFIG_SPL_USBETH_SUPPORT
+#define CONFIG_BOOTCOMMAND \
+	"setenv autoload no; " \
+	"setenv ethact usb_ether; " \
+	"dhcp; "	\
+	"if tftp 80000000 debrick.scr; then "	\
+		"source 80000000; "	\
+	"fi"
+#else
+#define CONFIG_BOOTCOMMAND \
+	"setenv autoload no; " \
+	"setenv ethact cpsw; " \
+	"dhcp; "	\
+	"if tftp 80000000 debrick.scr; then "	\
+		"source 80000000; "	\
+	"fi"
+#endif
+#endif
+
+/* Clock Defines */
+#define V_OSCK				24000000  /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define CONFIG_CMD_ECHO
+
+/* max number of command args */
+#define CONFIG_SYS_MAXARGS		16
+
+/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE		512
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE \
+					+ sizeof(CONFIG_SYS_PROMPT) + 16)
+
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+/*
+ * memtest works on 8 MB in DRAM after skipping 32MB from
+ * start addr of ram disk
+ */
+#define CONFIG_SYS_MEMTEST_START	(PHYS_DRAM_1 + (64 * 1024 * 1024))
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START \
+					+ (8 * 1024 * 1024))
+
+#define CONFIG_SYS_LOAD_ADDR		0x81000000 /* Default load address */
+#define CONFIG_SYS_HZ			1000 /* 1ms clock */
+
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_OMAP_HSMMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_SPI
+#define CONFIG_OMAP3_SPI
+#define CONFIG_MTD_DEVICE
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		(24000000)
+
+/* USB Composite download gadget - g_dnl */
+#define CONFIG_USB_GADGET
+#define CONFIG_USBDOWNLOAD_GADGET
+
+/* USB TI's IDs */
+#define CONFIG_USBD_HS
+#define CONFIG_G_DNL_VENDOR_NUM 0x0403
+#define CONFIG_G_DNL_PRODUCT_NUM 0xBD00
+#define CONFIG_G_DNL_MANUFACTURER "Texas Instruments"
+
+/* USB Device Firmware Update support */
+#define CONFIG_DFU_FUNCTION
+#define CONFIG_DFU_MMC
+/* #define CONFIG_DFU_NAND*/
+#define CONFIG_CMD_DFU
+#define DFU_ALT_INFO_MMC \
+	"boot part 0 1;" \
+	"rootfs part 0 2;" \
+	"MLO fat 0 1;" \
+	"MLO.raw mmc 100 100;" \
+	"u-boot.img.raw mmc 300 3C0;" \
+	"u-boot.img fat 0 1;" \
+	"uEnv.txt fat 0 1"
+#define DFU_ALT_INFO_NAND \
+	"SPL part 0 1;" \
+	"SPL.backup1 part 0 2;" \
+	"SPL.backup2 part 0 3;" \
+	"SPL.backup3 part 0 4;" \
+	"u-boot part 0 5;" \
+	"kernel part 0 7;" \
+	"rootfs part 0 8"
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1		/*  1 bank of DRAM */
+#define PHYS_DRAM_1			0x80000000	/* DRAM Bank #1 */
+#define CONFIG_MAX_RAM_BANK_SIZE	(1024 << 20)	/* 1GB */
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_DRAM_1
+#define CONFIG_SYS_INIT_SP_ADDR         (NON_SECURE_SRAM_END - \
+						GENERATED_GBL_DATA_SIZE)
+ /* Platform/Board specific defs */
+#define CONFIG_SYS_TIMERBASE		0x48040000	/* Use Timer2 */
+#define CONFIG_SYS_PTV			2	/* Divisor: 2^(PTV+1) => 8 */
+#define CONFIG_SYS_HZ			1000
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SERIAL_MULTI
+#define CONFIG_SYS_NS16550_REG_SIZE	(-4)
+#define CONFIG_SYS_NS16550_CLK		(48000000)
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2		0x48022000	/* UART1 */
+#define CONFIG_SYS_NS16550_COM3		0x48024000	/* UART2 */
+#define CONFIG_SYS_NS16550_COM4		0x481a6000	/* UART3 */
+#define CONFIG_SYS_NS16550_COM5		0x481a8000	/* UART4 */
+#define CONFIG_SYS_NS16550_COM6		0x481aa000	/* UART5 */
+#define CONFIG_SERIAL1
+#define CONFIG_CONS_INDEX		1
+
+/* I2C Configuration */
+#define CONFIG_I2C
+#define CONFIG_CMD_I2C
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_DRIVER_OMAP24XX_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50	/* Main EEPROM */
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+
+#define CONFIG_OMAP_GPIO
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 110, 300, 600, 1200, 2400, \
+4800, 9600, 14400, 19200, 28800, 38400, 56000, 57600, 115200 }
+
+#define CONFIG_ENV_OVERWRITE		1
+#define CONFIG_SYS_CONSOLE_INFO_QUIET
+
+#define CONFIG_ENV_IS_NOWHERE
+
+#ifndef CONFIG_NOR_BOOT
+/* Defines for SPL */
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_TEXT_BASE		0x402F0400
+#define CONFIG_SPL_MAX_SIZE		(101 * 1024)
+#define CONFIG_SPL_STACK		CONFIG_SYS_INIT_SP_ADDR
+
+#define CONFIG_SPL_OS_BOOT
+#define CONFIG_SPL_BSS_START_ADDR	0x80a00000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000		/* 512 KB */
+
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR	0x300 /* address 0x60000 */
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS	0x200 /* 256 KB */
+#define CONFIG_SYS_MMC_SD_FAT_BOOT_PARTITION	1
+#define CONFIG_SPL_FAT_LOAD_PAYLOAD_NAME	"u-boot.img"
+
+#ifdef CONFIG_SPL_OS_BOOT
+#define CONFIG_SYS_SPL_ARGS_ADDR		(PHYS_DRAM_1 + 0x100)
+/* fat */
+#define CONFIG_SPL_FAT_LOAD_KERNEL_NAME		"uImage"
+#define CONFIG_SPL_FAT_LOAD_ARGS_NAME		"args"
+/* raw mmc */
+#define CONFIG_SYS_MMCSD_RAW_MODE_KERNEL_SECTOR	0x500 /* address 0xa0000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTOR	0x8   /* address 0x1000 */
+#define CONFIG_SYS_MMCSD_RAW_MODE_ARGS_SECTORS	8     /* 4KB */
+/* nand */
+#define CONFIG_CMD_SPL_NAND_OFS			0x240000 /* end of u-boot */
+#define CONFIG_SYS_NAND_SPL_KERNEL_OFFS		0x280000
+#define CONFIG_CMD_SPL_WRITE_SIZE		0x1000
+/* spl export command */
+#define CONFIG_CMD_SPL
+#endif
+
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_FAT_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBDISK_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_GPIO_SUPPORT
+#define CONFIG_SPL_YMODEM_SUPPORT
+#define CONFIG_SPL_NET_SUPPORT
+#define CONFIG_SPL_NET_VCI_STRING	"AM335x U-Boot SPL"
+#define CONFIG_SPL_ETH_SUPPORT
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SPL_SPI_BUS		0
+#define CONFIG_SPL_SPI_CS		0
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x80000
+/*#define CONFIG_SPL_MUSB_NEW_SUPPORT*/
+#define CONFIG_SPL_LDSCRIPT		"$(CPUDIR)/omap-common/u-boot-spl.lds"
+
+#define CONFIG_SPL_BOARD_INIT
+#define CONFIG_SPL_NAND_AM33XX_BCH
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_DRIVERS
+#define CONFIG_SPL_NAND_ECC
+#endif
+
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_OOBSIZE		64
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128*1024)
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{ 2, 3, 4, 5, 6, 7, 8, 9, \
+					 10, 11, 12, 13, 14, 15, 16, 17, \
+					 18, 19, 20, 21, 22, 23, 24, 25, \
+					 26, 27, 28, 29, 30, 31, 32, 33, \
+					 34, 35, 36, 37, 38, 39, 40, 41, \
+					 42, 43, 44, 45, 46, 47, 48, 49, \
+					 50, 51, 52, 53, 54, 55, 56, 57, }
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	14
+
+#define CONFIG_SYS_NAND_ECCSTEPS	4
+#define	CONFIG_SYS_NAND_ECCTOTAL	(CONFIG_SYS_NAND_ECCBYTES * \
+						CONFIG_SYS_NAND_ECCSTEPS)
+
+#define	CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x80000
+
+/*
+ * 1MB into the SDRAM to allow for SPL's bss at the beginning of SDRAM
+ * 64 bytes before this address should be set aside for u-boot.img's
+ * header. That is 0x800FFFC0--0x80100000 should not be used for any
+ * other needs.
+ */
+#ifdef CONFIG_NOR_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x08000000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x80800000
+#endif
+#define CONFIG_SYS_SPL_MALLOC_START	0x80a08000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+
+/* Since SPL did pll and ddr initialization for us,
+ * we don't need to do it twice.
+ */
+#if !defined(CONFIG_SPL_BUILD) && ! defined(CONFIG_NOR_BOOT)
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * USB configuration
+ */
+#ifndef CONFIG_SPL_BUILD
+
+#define CONFIG_USB_MUSB_DSPS
+#define CONFIG_ARCH_MISC_INIT
+#define CONFIG_MUSB_GADGET
+#define CONFIG_MUSB_PIO_ONLY
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+#define CONFIG_MUSB_HOST
+#define CONFIG_AM335X_USB0
+#define CONFIG_AM335X_USB0_MODE	MUSB_PERIPHERAL
+#define CONFIG_AM335X_USB1
+#define CONFIG_AM335X_USB1_MODE MUSB_HOST
+
+#ifdef CONFIG_MUSB_HOST
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#endif
+
+#ifdef CONFIG_MUSB_GADGET
+#define CONFIG_USB_ETHER
+#define CONFIG_USB_ETH_RNDIS
+#define CONFIG_USBNET_HOST_ADDR	"de:ad:be:af:00:00"
+#endif /* CONFIG_MUSB_GADGET */
+
+#endif
+
+/*
+ * Default to using SPI for environment, etc.  We have multiple copies
+ * of SPL as the ROM will check these locations.
+ * 0x0 - 0x20000 : First copy of SPL
+ * 0x20000 - 0x40000 : Second copy of SPL
+ * 0x40000 - 0x60000 : Third copy of SPL
+ * 0x60000 - 0x80000 : Fourth copy of SPL
+ * 0x80000 - 0xDF000 : U-Boot
+ * 0xDF000 - 0xE0000 : U-Boot Environment
+ * 0xE0000 - 0x442000 : Linux Kernel
+ * 0x442000 - 0x800000 : Userland
+ */
+#if defined(CONFIG_SPI_BOOT)
+# undef CONFIG_ENV_IS_NOWHERE
+# define CONFIG_ENV_IS_IN_SPI_FLASH
+# define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+# define CONFIG_ENV_OFFSET		(892 << 10) /* 892 KiB in */
+# define CONFIG_ENV_SECT_SIZE		(4 << 10) /* 4 KB sectors */
+#endif /* SPI support */
+
+#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_USBETH_SUPPORT)
+/* disable host part of MUSB in SPL */
+#undef CONFIG_MUSB_HOST
+/*
+ * Disable UART SPL support so we fit within the 101KiB limit.
+ */
+#undef CONFIG_SPL_ETH_SUPPORT
+#endif
+
+/* Unsupported features */
+#undef CONFIG_USE_IRQ
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_PING
+#define CONFIG_DRIVER_TI_CPSW
+#define CONFIG_MII
+#define CONFIG_CMD_MII
+#define CONFIG_BOOTP_DEFAULT
+#define CONFIG_BOOTP_DNS
+#define CONFIG_BOOTP_DNS2
+#define CONFIG_BOOTP_SEND_HOSTNAME
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_NET_RETRY_COUNT         10
+#define CONFIG_NET_MULTI
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ADDR			0
+#define CONFIG_PHY_SMSC
+
+#define CONFIG_NAND
+/* NAND support */
+#ifdef CONFIG_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_MTDPARTS
+#define MTDIDS_DEFAULT			"nand0=omap2-nand.0"
+#define MTDPARTS_DEFAULT		"mtdparts=omap2-nand.0:128k(SPL)," \
+					"128k(SPL.backup1)," \
+					"128k(SPL.backup2)," \
+					"128k(SPL.backup3),1792k(u-boot)," \
+					"128k(u-boot-spl-os)," \
+					"128k(u-boot-env),5m(kernel),-(rootfs)"
+#define CONFIG_NAND_OMAP_GPMC
+#define GPMC_NAND_ECC_LP_x16_LAYOUT	1
+#define CONFIG_SYS_NAND_BASE		(0x08000000)	/* physical address */
+							/* to access nand at */
+							/* CS0 */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1		/* Max number of NAND
+							   devices */
+#if !defined(CONFIG_SPI_BOOT) && !defined(CONFIG_NOR_BOOT)
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x260000 /* environment starts here */
+#define CONFIG_SYS_ENV_SECT_SIZE	(128 << 10)	/* 128 KiB */
+#endif
+#endif
+
+/*
+ *  * NOR Size = 16 MB
+ *   * No.Of Sectors/Blocks = 128
+ *    * Sector Size = 128 KB
+ *     * Word lenght = 16 bits
+ *      */
+#if defined(CONFIG_NOR)
+#undef CONFIG_SYS_NO_FLASH
+#undef CONFIG_SYS_MALLOC_LEN
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE 1
+#define CONFIG_SYS_FLASH_PROTECTION
+#define CONFIG_SYS_MALLOC_LEN		(0x100000)
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_SYS_MAX_FLASH_SECT	128
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_SYS_FLASH_BASE		(0x08000000)
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_FLASH_BASE
+#define NOR_SECT_SIZE			(128 * 1024)
+#ifdef CONFIG_NOR_BOOT
+#undef CONFIG_ENV_IS_NOWHERE
+#define CONFIG_ENV_IS_IN_FLASH  1
+#define CONFIG_SYS_ENV_SECT_SIZE	(2 * NOR_SECT_SIZE)
+#define CONFIG_ENV_SECT_SIZE		(2 * NOR_SECT_SIZE)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(2 * NOR_SECT_SIZE) /* After 1 MB */
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + \
+         CONFIG_ENV_OFFSET)
+#endif
+#define CONFIG_MTD_DEVICE
+#define CONFIG_CMD_FLASH
+#endif  /* NOR support */
+
+#endif	/* ! __CONFIG_HTOUCH_H */
diff --git a/include/cpsw.h b/include/cpsw.h
index 296b0e5..390f7bc 100644
--- a/include/cpsw.h
+++ b/include/cpsw.h
@@ -42,6 +42,8 @@ struct cpsw_platform_data {
 	u32	mac_control;
 	struct cpsw_slave_data	*slave_data;
 	void	(*control)(int enabled);
+	void (*phy_init1)(char *name, int addr);
+	u32 gigabit_en; /* gigabit capable AND enabled */
 	u32	host_port_num;
 	u8	version;
 };
diff --git a/include/power/tps65217.h b/include/power/tps65217.h
new file mode 100644
index 0000000..297c4cb
--- /dev/null
+++ b/include/power/tps65217.h
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2011-2013
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * For more details, please see the TRM at http://www.ti.com/product/tps65217a
+ */
+
+#ifndef __POWER_TPS65217_H__
+#define __POWER_TPS65217_H__
+
+/* I2C chip address */
+#define TPS65217_CHIP_PM			0x24
+
+/* Registers */
+enum {
+	TPS65217_CHIPID				= 0x00,
+	TPS65217_POWER_PATH,
+	TPS65217_INTERRUPT,
+	TPS65217_CHGCONFIG0,
+	TPS65217_CHGCONFIG1,
+	TPS65217_CHGCONFIG2,
+	TPS65217_CHGCONFIG3,
+	TPS65217_WLEDCTRL1,
+	TPS65217_WLEDCTRL2,
+	TPS65217_MUXCTRL,
+	TPS65217_STATUS,
+	TPS65217_PASSWORD,
+	TPS65217_PGOOD,
+	TPS65217_DEFPG,
+	TPS65217_DEFDCDC1,
+	TPS65217_DEFDCDC2,
+	TPS65217_DEFDCDC3,
+	TPS65217_DEFSLEW,
+	TPS65217_DEFLDO1,
+	TPS65217_DEFLDO2,
+	TPS65217_DEFLS1,
+	TPS65217_DEFLS2,
+	TPS65217_ENABLE,
+	TPS65217_DEFUVLO,
+	TPS65217_SEQ1,
+	TPS65217_SEQ2,
+	TPS65217_SEQ3,
+	TPS65217_SEQ4,
+	TPS65217_SEQ5,
+	TPS65217_SEQ6,
+	TPS65217_PMIC_NUM_OF_REGS,
+};
+
+#define TPS65217_PROT_LEVEL_NONE		0x00
+#define TPS65217_PROT_LEVEL_1			0x01
+#define TPS65217_PROT_LEVEL_2			0x02
+
+#define TPS65217_PASSWORD_LOCK_FOR_WRITE	0x00
+#define TPS65217_PASSWORD_UNLOCK		0x7D
+
+#define TPS65217_DCDC_GO			0x80
+
+#define TPS65217_MASK_ALL_BITS			0xFF
+
+#define TPS65217_USB_INPUT_CUR_LIMIT_MASK	0x03
+#define TPS65217_USB_INPUT_CUR_LIMIT_100MA	0x00
+#define TPS65217_USB_INPUT_CUR_LIMIT_500MA	0x01
+#define TPS65217_USB_INPUT_CUR_LIMIT_1300MA	0x02
+#define TPS65217_USB_INPUT_CUR_LIMIT_1800MA	0x03
+
+#define TPS65217_DCDC_VOLT_SEL_1125MV		0x09
+#define TPS65217_DCDC_VOLT_SEL_1275MV		0x0F
+#define TPS65217_DCDC_VOLT_SEL_1325MV		0x11
+
+#define TPS65217_LDO_MASK			0x1F
+#define TPS65217_LDO_VOLTAGE_OUT_1_8		0x06
+#define TPS65217_LDO_VOLTAGE_OUT_3_3		0x1F
+
+#define TPS65217_PWR_SRC_USB_BITMASK		0x4
+#define TPS65217_PWR_SRC_AC_BITMASK		0x8
+
+int tps65217_reg_read(uchar src_reg, uchar *src_val);
+int tps65217_reg_write(uchar prot_level, uchar dest_reg, uchar dest_val,
+		       uchar mask);
+int tps65217_voltage_update(uchar dc_cntrl_reg, uchar volt_sel);
+#endif	/* __POWER_TPS65217_H__ */
diff --git a/include/power/tps65910.h b/include/power/tps65910.h
new file mode 100644
index 0000000..ca84301
--- /dev/null
+++ b/include/power/tps65910.h
@@ -0,0 +1,77 @@
+/*
+ * (C) Copyright 2011-2013
+ * Texas Instruments, <www.ti.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * For more details, please see the TRM at http://www.ti.com/product/tps65910
+ */
+#ifndef __POWER_TPS65910_H__
+#define __POWER_TPS65910_H__
+
+#define MPU     0
+#define CORE    1
+
+#define TPS65910_SR_I2C_ADDR				0x12
+#define TPS65910_CTRL_I2C_ADDR				0x2D
+
+/* PMIC Register offsets */
+enum {
+	TPS65910_VDD1_REG				= 0x21,
+	TPS65910_VDD1_OP_REG				= 0x22,
+	TPS65910_VDD2_REG				= 0x24,
+	TPS65910_VDD2_OP_REG				= 0x25,
+	TPS65910_DEVCTRL_REG				= 0x3F,
+};
+
+/* VDD2 & VDD1 control register (VDD2_REG & VDD1_REG) */
+#define TPS65910_VGAIN_SEL_MASK				(0x3 << 6)
+#define TPS65910_ILMAX_MASK				(0x1 << 5)
+#define TPS65910_TSTEP_MASK				(0x7 << 2)
+#define TPS65910_ST_MASK				(0x3)
+
+#define TPS65910_REG_VGAIN_SEL_X1			(0x0 << 6)
+#define TPS65910_REG_VGAIN_SEL_X1_0			(0x1 << 6)
+#define TPS65910_REG_VGAIN_SEL_X3			(0x2 << 6)
+#define TPS65910_REG_VGAIN_SEL_X4			(0x3 << 6)
+
+#define TPS65910_REG_ILMAX_1_0_A			(0x0 << 5)
+#define TPS65910_REG_ILMAX_1_5_A			(0x1 << 5)
+
+#define TPS65910_REG_TSTEP_				(0x0 << 2)
+#define TPS65910_REG_TSTEP_12_5				(0x1 << 2)
+#define TPS65910_REG_TSTEP_9_4				(0x2 << 2)
+#define TPS65910_REG_TSTEP_7_5				(0x3 << 2)
+#define TPS65910_REG_TSTEP_6_25				(0x4 << 2)
+#define TPS65910_REG_TSTEP_4_7				(0x5 << 2)
+#define TPS65910_REG_TSTEP_3_12				(0x6 << 2)
+#define TPS65910_REG_TSTEP_2_5				(0x7 << 2)
+
+#define TPS65910_REG_ST_OFF				(0x0)
+#define TPS65910_REG_ST_ON_HI_POW			(0x1)
+#define TPS65910_REG_ST_OFF_1				(0x2)
+#define TPS65910_REG_ST_ON_LOW_POW			(0x3)
+
+
+/* VDD2 & VDD1 voltage selection register. (VDD2_OP_REG & VDD1_OP_REG) */
+#define TPS65910_OP_REG_SEL				(0x7F)
+
+#define TPS65910_OP_REG_CMD_MASK			(0x1 << 7)
+#define TPS65910_OP_REG_CMD_OP				(0x0 << 7)
+#define TPS65910_OP_REG_CMD_SR				(0x1 << 7)
+
+#define TPS65910_OP_REG_SEL_MASK			(0x7F)
+#define TPS65910_OP_REG_SEL_0_9_5			(0x1F)	/* 0.9500 V */
+#define TPS65910_OP_REG_SEL_1_1_3			(0x2E)	/* 1.1375 V */
+#define TPS65910_OP_REG_SEL_1_2_0			(0x33)	/* 1.2000 V */
+#define TPS65910_OP_REG_SEL_1_2_6			(0x38)	/* 1.2625 V */
+#define TPS65910_OP_REG_SEL_1_3_2_5			(0x3D)	/* 1.3250 V */
+
+/* Device control register . (DEVCTRL_REG) */
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_MASK		(0x1 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_SR_I2C	(0x0 << 4)
+#define TPS65910_DEVCTRL_REG_SR_CTL_I2C_SEL_CTL_I2C	(0x1 << 4)
+
+int tps65910_set_i2c_control(void);
+int tps65910_voltage_update(unsigned int module, unsigned char vddx_op_vol_sel);
+#endif	/* __POWER_TPS65910_H__ */
-- 
1.9.1

